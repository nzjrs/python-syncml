/* This file was generated by PyBindGen 0.8.0.429 */
#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <stddef.h>


#if PY_VERSION_HEX < 0x02040000

#define Py_CLEAR(op)				\
        do {                            	\
                if (op) {			\
                        PyObject *tmp = (PyObject *)(op);	\
                        (op) = NULL;		\
                        Py_DECREF(tmp);		\
                }				\
        } while (0)


#define Py_VISIT(op)							\
        do { 								\
                if (op) {						\
                        int vret = visit((PyObject *)(op), arg);	\
                        if (vret)					\
                                return vret;				\
                }							\
        } while (0)

#endif



#if PY_VERSION_HEX < 0x02050000

typedef int Py_ssize_t;
# define PY_SSIZE_T_MAX INT_MAX
# define PY_SSIZE_T_MIN INT_MIN
typedef inquiry lenfunc;
typedef intargfunc ssizeargfunc;
typedef intobjargproc ssizeobjargproc;

#endif


#if     __GNUC__ > 2
# define PYBINDGEN_UNUSED(param) param __attribute__((__unused__))
#elif     __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
# define PYBINDGEN_UNUSED(param) __attribute__((__unused__)) param
#else
# define PYBINDGEN_UNUSED(param)
#endif  /* !__GNUC__ */

#include "pysyncml.h"
/* --- forward declarations --- */


typedef struct {
    PyObject_HEAD
    SmlTransportData *obj;
} PySmlTransportData;
    

extern PyTypeObject PySmlTransportData_Type;


typedef struct {
    PyObject_HEAD
    SmlDevInfAgent *obj;
} PySmlDevInfAgent;
    

extern PyTypeObject PySmlDevInfAgent_Type;


typedef struct {
    PyObject_HEAD
    SmlAnchor *obj;
} PySmlAnchor;
    

extern PyTypeObject PySmlAnchor_Type;


typedef struct {
    PyObject_HEAD
    SmlDevInfDataStore *obj;
} PySmlDevInfDataStore;
    

extern PyTypeObject PySmlDevInfDataStore_Type;


typedef struct {
    PyObject_HEAD
    SmlDevInfPropParam *obj;
} PySmlDevInfPropParam;
    

extern PyTypeObject PySmlDevInfPropParam_Type;


typedef struct {
    PyObject_HEAD
    SmlDevInfContentType *obj;
} PySmlDevInfContentType;
    

extern PyTypeObject PySmlDevInfContentType_Type;


typedef struct {
    PyObject_HEAD
    SmlDevInfCTCap *obj;
} PySmlDevInfCTCap;
    

extern PyTypeObject PySmlDevInfCTCap_Type;


typedef struct {
    PyObject_HEAD
    SmlDevInf *obj;
} PySmlDevInf;
    

extern PyTypeObject PySmlDevInf_Type;


typedef struct {
    PyObject_HEAD
    SmlChal *obj;
} PySmlChal;
    

extern PyTypeObject PySmlChal_Type;


typedef struct {
    PyObject_HEAD
    SmlNotification *obj;
} PySmlNotification;
    

extern PyTypeObject PySmlNotification_Type;


typedef struct {
    PyObject_HEAD
    SmlMapItem *obj;
} PySmlMapItem;
    

extern PyTypeObject PySmlMapItem_Type;


typedef struct {
    PyObject_HEAD
    SmlHeader *obj;
} PySmlHeader;
    

extern PyTypeObject PySmlHeader_Type;


typedef struct {
    PyObject_HEAD
    SmlManager *obj;
} PySmlManager;
    

extern PyTypeObject PySmlManager_Type;


typedef struct {
    PyObject_HEAD
    SmlLocation *obj;
} PySmlLocation;
    

extern PyTypeObject PySmlLocation_Type;


typedef struct {
    PyObject_HEAD
    SmlDevInfProperty *obj;
} PySmlDevInfProperty;
    

extern PyTypeObject PySmlDevInfProperty_Type;


typedef struct {
    PyObject_HEAD
    SmlTransport *obj;
} PySmlTransport;
    

extern PyTypeObject PySmlTransport_Type;


typedef struct {
    PyObject_HEAD
    SmlItem *obj;
} PySmlItem;
    

extern PyTypeObject PySmlItem_Type;


typedef struct {
    PyObject_HEAD
    SmlCommand *obj;
} PySmlCommand;
    

extern PyTypeObject PySmlCommand_Type;


typedef struct {
    PyObject_HEAD
    SmlCred *obj;
} PySmlCred;
    

extern PyTypeObject PySmlCred_Type;


typedef struct {
    PyObject_HEAD
    SmlLink *obj;
} PySmlLink;
    

extern PyTypeObject PySmlLink_Type;


typedef struct {
    PyObject_HEAD
    SmlSession *obj;
} PySmlSession;
    

extern PyTypeObject PySmlSession_Type;


typedef struct {
    PyObject_HEAD
    SmlObject *obj;
} PySmlObject;
    

extern PyTypeObject PySmlObject_Type;


typedef struct {
    PyObject_HEAD
    SmlAuthenticator *obj;
} PySmlAuthenticator;
    

extern PyTypeObject PySmlAuthenticator_Type;


typedef struct {
    PyObject_HEAD
    SmlStatus *obj;
} PySmlStatus;
    

extern PyTypeObject PySmlStatus_Type;


typedef struct {
    PyObject_HEAD
    SmlSanAlert *obj;
} PySmlSanAlert;
    

extern PyTypeObject PySmlSanAlert_Type;

static PyMethodDef syncml_std_functions[] = {
    {NULL, NULL, 0, NULL}
};

void _SmlManagerEventCb(SmlManager *manager, SmlManagerEventType type, SmlSession *session, SmlError *error, void *userdata)
{
    PyObject *py_callback, *py_eventType, *arglist;
    PySmlSession *py_session;
    PyGILState_STATE gstate;

    py_callback = (PyObject *)userdata;
    py_eventType = PyInt_FromLong(type);
    py_session = PyObject_New(PySmlSession, &PySmlSession_Type);
    py_session->obj = session;

    // Build up the argument list...
    arglist = Py_BuildValue("(OO)", py_eventType, py_session);

    // for calling the Python compare callback function.
    gstate = PyGILState_Ensure();
    PyEval_CallObject(py_callback,arglist);

    Py_DECREF(arglist);
    Py_DECREF(py_session);
    PyGILState_Release(gstate);
}

void _SmlCommandCb(SmlSession *session, SmlCommand *cmd, void *userdata)
{
    PyObject *py_callback, *arglist;
    PySmlCommand *py_command;
    PySmlSession *py_session;
    PyGILState_STATE gstate;

    py_callback = (PyObject *)userdata;
    py_session = PyObject_New(PySmlSession, &PySmlSession_Type);
    py_session->obj = session;

    py_command = PyObject_New(PySmlCommand, &PySmlCommand_Type);
    py_command->obj = cmd;

    // Build up the argument list...
    arglist = Py_BuildValue("(OO)", py_session, py_command);

    // for calling the Python compare callback function.
    gstate = PyGILState_Ensure();
    PyEval_CallObject(py_callback,arglist);

    Py_DECREF(arglist);
    Py_DECREF(py_session);
    Py_DECREF(py_command);
    PyGILState_Release(gstate);
}


static PyObject *
initsyncml_std(void)
{
    PyObject *m;
    m = Py_InitModule3((char *) "syncml.std", syncml_std_functions, NULL);
    if (m == NULL) {
        return NULL;
    }
    return m;
}
/* --- module functions --- */


PyObject *
_wrap_syncmlsmlCommandNewAlert(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlCommand *retval;
    SmlAlertType type2;
    PySmlLocation *target2;
    SmlLocation *target_ptr;
    PySmlLocation *source2;
    SmlLocation *source_ptr;
    const char *next2;
    const char *last2;
    const char *contenttype2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"type", "target", "source", "next", "last", "contenttype", NULL};
    PySmlCommand *py_SmlCommand;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iO!O!sss", (char **) keywords, &type2, &PySmlLocation_Type, &target2, &PySmlLocation_Type, &source2, &next2, &last2, &contenttype2)) {
        return NULL;
    }
    target_ptr = (target2 ? target2->obj : NULL);
    source_ptr = (source2 ? source2->obj : NULL);
    retval = smlCommandNewAlert(type2, target_ptr, source_ptr, next2, last2, contenttype2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_SmlCommand = PyObject_New(PySmlCommand, &PySmlCommand_Type);
    py_SmlCommand->obj = retval;
    py_retval = Py_BuildValue((char *) "N", py_SmlCommand);
    return py_retval;
}
PyObject * _wrap_syncmlsmlCommandNewAlert(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlManagerObjectFree(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlObject *object2;
    SmlObject *object_ptr;
    const char *keywords[] = {"object", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlObject_Type, &object2)) {
        return NULL;
    }
    object_ptr = (object2 ? object2->obj : NULL);
    smlManagerObjectFree(object_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}
PyObject * _wrap_syncmlsmlManagerObjectFree(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlNotificationFreeAlert(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlSanAlert *alert2;
    SmlSanAlert *alert_ptr;
    const char *keywords[] = {"alert", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlSanAlert_Type, &alert2)) {
        return NULL;
    }
    alert_ptr = (alert2 ? alert2->obj : NULL);
    smlNotificationFreeAlert(alert_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}
PyObject * _wrap_syncmlsmlNotificationFreeAlert(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlAuthIsEnabled(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlAuthenticator *auth2;
    SmlAuthenticator *auth_ptr;
    const char *keywords[] = {"auth", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlAuthenticator_Type, &auth2)) {
        return NULL;
    }
    auth_ptr = (auth2 ? auth2->obj : NULL);
    retval = smlAuthIsEnabled(auth_ptr);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}
PyObject * _wrap_syncmlsmlAuthIsEnabled(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlMD5GetDigest(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *buffer2;
    int buffer_size2;
    unsigned char *digest2;
    const char *keywords[] = {"buffer", "buffer_size", "digest", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "sis", (char **) keywords, &buffer2, &buffer_size2, &digest2)) {
        return NULL;
    }
    smlMD5GetDigest(buffer2, buffer_size2, digest2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}
PyObject * _wrap_syncmlsmlMD5GetDigest(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlCommandNewChange(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlCommand *retval;
    SmlChangeType type2;
    const char *uid2;
    const char *data2;
    unsigned int size2;
    const char *contenttype2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"type", "uid", "data", "size", "contenttype", NULL};
    PySmlCommand *py_SmlCommand;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "issIs", (char **) keywords, &type2, &uid2, &data2, &size2, &contenttype2)) {
        return NULL;
    }
    retval = smlCommandNewChange(type2, uid2, data2, size2, contenttype2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_SmlCommand = PyObject_New(PySmlCommand, &PySmlCommand_Type);
    py_SmlCommand->obj = retval;
    py_retval = Py_BuildValue((char *) "N", py_SmlCommand);
    return py_retval;
}
PyObject * _wrap_syncmlsmlCommandNewChange(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlDevInfFreeContentType(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlDevInfContentType *ct2;
    SmlDevInfContentType *ct_ptr;
    const char *keywords[] = {"ct", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlDevInfContentType_Type, &ct2)) {
        return NULL;
    }
    ct_ptr = (ct2 ? ct2->obj : NULL);
    smlDevInfFreeContentType(ct_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}
PyObject * _wrap_syncmlsmlDevInfFreeContentType(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlMD5ToString(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    char *retval;
    unsigned char *digest2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"digest", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &digest2)) {
        return NULL;
    }
    retval = smlMD5ToString(digest2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}
PyObject * _wrap_syncmlsmlMD5ToString(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlDevInfDevTypeFromString(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlDevInfDevTyp retval;
    const char *name2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"name", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &name2)) {
        return NULL;
    }
    retval = smlDevInfDevTypeFromString(name2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}
PyObject * _wrap_syncmlsmlDevInfDevTypeFromString(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlDevInfGetMaxGUIDSize(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int retval;
    PySmlDevInfDataStore *datastore2;
    SmlDevInfDataStore *datastore_ptr;
    const char *keywords[] = {"datastore", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlDevInfDataStore_Type, &datastore2)) {
        return NULL;
    }
    datastore_ptr = (datastore2 ? datastore2->obj : NULL);
    retval = smlDevInfGetMaxGUIDSize(datastore_ptr);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}
PyObject * _wrap_syncmlsmlDevInfGetMaxGUIDSize(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlAuthVerify(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlChal *chal2;
    SmlChal *chal_ptr;
    PySmlCred *cred2;
    SmlCred *cred_ptr;
    const char *username2;
    const char *password2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"chal", "cred", "username", "password", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!ss", (char **) keywords, &PySmlChal_Type, &chal2, &PySmlCred_Type, &cred2, &username2, &password2)) {
        return NULL;
    }
    chal_ptr = (chal2 ? chal2->obj : NULL);
    cred_ptr = (cred2 ? cred2->obj : NULL);
    retval = smlAuthVerify(chal_ptr, cred_ptr, username2, password2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}
PyObject * _wrap_syncmlsmlAuthVerify(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlAuthFree(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlAuthenticator *auth2;
    SmlAuthenticator *auth_ptr;
    const char *keywords[] = {"auth", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlAuthenticator_Type, &auth2)) {
        return NULL;
    }
    auth_ptr = (auth2 ? auth2->obj : NULL);
    smlAuthFree(auth_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}
PyObject * _wrap_syncmlsmlAuthFree(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlCommandNewPut(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlCommand *retval;
    PySmlLocation *target2;
    SmlLocation *target_ptr;
    PySmlLocation *source2;
    SmlLocation *source_ptr;
    const char *data2;
    unsigned int size2;
    const char *contenttype2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"target", "source", "data", "size", "contenttype", NULL};
    PySmlCommand *py_SmlCommand;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!sIs", (char **) keywords, &PySmlLocation_Type, &target2, &PySmlLocation_Type, &source2, &data2, &size2, &contenttype2)) {
        return NULL;
    }
    target_ptr = (target2 ? target2->obj : NULL);
    source_ptr = (source2 ? source2->obj : NULL);
    retval = smlCommandNewPut(target_ptr, source_ptr, data2, size2, contenttype2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_SmlCommand = PyObject_New(PySmlCommand, &PySmlCommand_Type);
    py_SmlCommand->obj = retval;
    py_retval = Py_BuildValue((char *) "N", py_SmlCommand);
    return py_retval;
}
PyObject * _wrap_syncmlsmlCommandNewPut(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlDevInfCTCapTypeToString(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *retval;
    SmlDevInfCTCapType type2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"type", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &type2)) {
        return NULL;
    }
    retval = smlDevInfCTCapTypeToString(type2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}
PyObject * _wrap_syncmlsmlDevInfCTCapTypeToString(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlAuthSetState(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlAuthenticator *auth2;
    SmlAuthenticator *auth_ptr;
    SmlErrorType type2;
    const char *keywords[] = {"auth", "type", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!i", (char **) keywords, &PySmlAuthenticator_Type, &auth2, &type2)) {
        return NULL;
    }
    auth_ptr = (auth2 ? auth2->obj : NULL);
    smlAuthSetState(auth_ptr, type2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}
PyObject * _wrap_syncmlsmlAuthSetState(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlCommandNewMap(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlCommand *retval;
    PySmlLocation *target2;
    SmlLocation *target_ptr;
    PySmlLocation *source2;
    SmlLocation *source_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"target", "source", NULL};
    PySmlCommand *py_SmlCommand;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PySmlLocation_Type, &target2, &PySmlLocation_Type, &source2)) {
        return NULL;
    }
    target_ptr = (target2 ? target2->obj : NULL);
    source_ptr = (source2 ? source2->obj : NULL);
    retval = smlCommandNewMap(target_ptr, source_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_SmlCommand = PyObject_New(PySmlCommand, &PySmlCommand_Type);
    py_SmlCommand->obj = retval;
    py_retval = Py_BuildValue((char *) "N", py_SmlCommand);
    return py_retval;
}
PyObject * _wrap_syncmlsmlCommandNewMap(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlCommandNewGet(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlCommand *retval;
    PySmlLocation *target2;
    SmlLocation *target_ptr;
    const char *contenttype2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"target", "contenttype", NULL};
    PySmlCommand *py_SmlCommand;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!s", (char **) keywords, &PySmlLocation_Type, &target2, &contenttype2)) {
        return NULL;
    }
    target_ptr = (target2 ? target2->obj : NULL);
    retval = smlCommandNewGet(target_ptr, contenttype2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_SmlCommand = PyObject_New(PySmlCommand, &PySmlCommand_Type);
    py_SmlCommand->obj = retval;
    py_retval = Py_BuildValue((char *) "N", py_SmlCommand);
    return py_retval;
}
PyObject * _wrap_syncmlsmlCommandNewGet(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlCommandNewPartialChange(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlCommand *retval;
    SmlChangeType type2;
    const char *uid2;
    const char *data2;
    unsigned int complete_size2;
    unsigned int partial_size2;
    const char *contenttype2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"type", "uid", "data", "complete_size", "partial_size", "contenttype", NULL};
    PySmlCommand *py_SmlCommand;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "issIIs", (char **) keywords, &type2, &uid2, &data2, &complete_size2, &partial_size2, &contenttype2)) {
        return NULL;
    }
    retval = smlCommandNewPartialChange(type2, uid2, data2, complete_size2, partial_size2, contenttype2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_SmlCommand = PyObject_New(PySmlCommand, &PySmlCommand_Type);
    py_SmlCommand->obj = retval;
    py_retval = Py_BuildValue((char *) "N", py_SmlCommand);
    return py_retval;
}
PyObject * _wrap_syncmlsmlCommandNewPartialChange(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlAuthRegister(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlAuthenticator *auth2;
    SmlAuthenticator *auth_ptr;
    PySmlManager *manager2;
    SmlManager *manager_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"auth", "manager", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PySmlAuthenticator_Type, &auth2, &PySmlManager_Type, &manager2)) {
        return NULL;
    }
    auth_ptr = (auth2 ? auth2->obj : NULL);
    manager_ptr = (manager2 ? manager2->obj : NULL);
    retval = smlAuthRegister(auth_ptr, manager_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}
PyObject * _wrap_syncmlsmlAuthRegister(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlDevInfDevTypeToString(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *retval;
    SmlDevInfDevTyp type2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"type", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &type2)) {
        return NULL;
    }
    retval = smlDevInfDevTypeToString(type2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}
PyObject * _wrap_syncmlsmlDevInfDevTypeToString(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlCredNew(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlCred *retval;
    SmlAuthType type2;
    SmlFormatType format2;
    const char *data2;
    const char *username2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"type", "format", "data", "username", NULL};
    PySmlCred *py_SmlCred;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iiss", (char **) keywords, &type2, &format2, &data2, &username2)) {
        return NULL;
    }
    retval = smlCredNew(type2, format2, data2, username2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_SmlCred = PyObject_New(PySmlCred, &PySmlCred_Type);
    py_SmlCred->obj = retval;
    py_retval = Py_BuildValue((char *) "N", py_SmlCred);
    return py_retval;
}
PyObject * _wrap_syncmlsmlCredNew(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlDevInfCTCapTypeFromString(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlDevInfCTCapType retval;
    const char *name2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"name", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &name2)) {
        return NULL;
    }
    retval = smlDevInfCTCapTypeFromString(name2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}
PyObject * _wrap_syncmlsmlDevInfCTCapTypeFromString(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlDevInfSetMaxGUIDSize(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlDevInfDataStore *datastore2;
    SmlDevInfDataStore *datastore_ptr;
    unsigned int max2;
    const char *keywords[] = {"datastore", "max", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!I", (char **) keywords, &PySmlDevInfDataStore_Type, &datastore2, &max2)) {
        return NULL;
    }
    datastore_ptr = (datastore2 ? datastore2->obj : NULL);
    smlDevInfSetMaxGUIDSize(datastore_ptr, max2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}
PyObject * _wrap_syncmlsmlDevInfSetMaxGUIDSize(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlAuthSetEnable(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlAuthenticator *auth2;
    SmlAuthenticator *auth_ptr;
    SmlBool enabled2;
    const char *keywords[] = {"auth", "enabled", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!i", (char **) keywords, &PySmlAuthenticator_Type, &auth2, &enabled2)) {
        return NULL;
    }
    auth_ptr = (auth2 ? auth2->obj : NULL);
    smlAuthSetEnable(auth_ptr, enabled2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}
PyObject * _wrap_syncmlsmlAuthSetEnable(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_syncmlsmlCommandNewSync(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlCommand *retval;
    PySmlLocation *target2;
    SmlLocation *target_ptr;
    PySmlLocation *source2;
    SmlLocation *source_ptr;
    unsigned int num_changes2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"target", "source", "num_changes", NULL};
    PySmlCommand *py_SmlCommand;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!I", (char **) keywords, &PySmlLocation_Type, &target2, &PySmlLocation_Type, &source2, &num_changes2)) {
        return NULL;
    }
    target_ptr = (target2 ? target2->obj : NULL);
    source_ptr = (source2 ? source2->obj : NULL);
    retval = smlCommandNewSync(target_ptr, source_ptr, num_changes2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_SmlCommand = PyObject_New(PySmlCommand, &PySmlCommand_Type);
    py_SmlCommand->obj = retval;
    py_retval = Py_BuildValue((char *) "N", py_SmlCommand);
    return py_retval;
}
PyObject * _wrap_syncmlsmlCommandNewSync(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);

static PyMethodDef syncml_functions[] = {
    {(char *) "smlCommandNewAlert", (PyCFunction) _wrap_syncmlsmlCommandNewAlert, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlManagerObjectFree", (PyCFunction) _wrap_syncmlsmlManagerObjectFree, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlNotificationFreeAlert", (PyCFunction) _wrap_syncmlsmlNotificationFreeAlert, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlAuthIsEnabled", (PyCFunction) _wrap_syncmlsmlAuthIsEnabled, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlMD5GetDigest", (PyCFunction) _wrap_syncmlsmlMD5GetDigest, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlCommandNewChange", (PyCFunction) _wrap_syncmlsmlCommandNewChange, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlDevInfFreeContentType", (PyCFunction) _wrap_syncmlsmlDevInfFreeContentType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlMD5ToString", (PyCFunction) _wrap_syncmlsmlMD5ToString, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlDevInfDevTypeFromString", (PyCFunction) _wrap_syncmlsmlDevInfDevTypeFromString, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlDevInfGetMaxGUIDSize", (PyCFunction) _wrap_syncmlsmlDevInfGetMaxGUIDSize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlAuthVerify", (PyCFunction) _wrap_syncmlsmlAuthVerify, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlAuthFree", (PyCFunction) _wrap_syncmlsmlAuthFree, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlCommandNewPut", (PyCFunction) _wrap_syncmlsmlCommandNewPut, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlDevInfCTCapTypeToString", (PyCFunction) _wrap_syncmlsmlDevInfCTCapTypeToString, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlAuthSetState", (PyCFunction) _wrap_syncmlsmlAuthSetState, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlCommandNewMap", (PyCFunction) _wrap_syncmlsmlCommandNewMap, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlCommandNewGet", (PyCFunction) _wrap_syncmlsmlCommandNewGet, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlCommandNewPartialChange", (PyCFunction) _wrap_syncmlsmlCommandNewPartialChange, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlAuthRegister", (PyCFunction) _wrap_syncmlsmlAuthRegister, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlDevInfDevTypeToString", (PyCFunction) _wrap_syncmlsmlDevInfDevTypeToString, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlCredNew", (PyCFunction) _wrap_syncmlsmlCredNew, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlDevInfCTCapTypeFromString", (PyCFunction) _wrap_syncmlsmlDevInfCTCapTypeFromString, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlDevInfSetMaxGUIDSize", (PyCFunction) _wrap_syncmlsmlDevInfSetMaxGUIDSize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlAuthSetEnable", (PyCFunction) _wrap_syncmlsmlAuthSetEnable, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "smlCommandNewSync", (PyCFunction) _wrap_syncmlsmlCommandNewSync, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};
/* --- classes --- */



static int
_wrap_PySmlTransportData__tp_init(PySmlTransportData *self, PyObject *args, PyObject *kwargs)
{
    char *data2;
    long unsigned int size2;
    SmlMimeType mimetype2;
    SmlBool ownsData2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"data", "size", "mimetype", "ownsData", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "siii", (char **) keywords, &data2, &size2, &mimetype2, &ownsData2)) {
        return -1;
    }
    self->obj = smlTransportDataNew(data2, size2, mimetype2, ownsData2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}


PyObject *
_wrap_syncmlsmlTransportDataDeref(PySmlTransportData *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlTransportDataDeref(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PySmlTransportData_methods[] = {
    {(char *) "Deref", (PyCFunction) _wrap_syncmlsmlTransportDataDeref, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlTransportData__tp_dealloc(PySmlTransportData *self)
{
    if (self->obj) {
    SmlTransportData *tmp = self->obj;
    self->obj = NULL;
    smlTransportDataDeref(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlTransportData__tp_richcompare (PySmlTransportData *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlTransportData_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlTransportData",            /* tp_name */
    sizeof(PySmlTransportData),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlTransportData__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlTransportData__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlTransportData_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlTransportData__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlDevInfAgent__tp_init(PySmlDevInfAgent *self, PyObject *args, PyObject *kwargs)
{
    PySmlDevInf *devinf2;
    SmlDevInf *devinf_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"devinf", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlDevInf_Type, &devinf2)) {
        return -1;
    }
    devinf_ptr = (devinf2 ? devinf2->obj : NULL);
    self->obj = smlDevInfAgentNew(devinf_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}


PyObject *
_wrap_syncmlsmlDevInfAgentSetDevInf(PySmlDevInfAgent *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlDevInf *devinf2;
    SmlDevInf *devinf_ptr;
    const char *keywords[] = {"devinf", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlDevInf_Type, &devinf2)) {
        return NULL;
    }
    devinf_ptr = (devinf2 ? devinf2->obj : NULL);
    smlDevInfAgentSetDevInf(self->obj, devinf_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfAgentRegister(PySmlDevInfAgent *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlManager *manager2;
    SmlManager *manager_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"manager", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlManager_Type, &manager2)) {
        return NULL;
    }
    manager_ptr = (manager2 ? manager2->obj : NULL);
    retval = smlDevInfAgentRegister(self->obj, manager_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfAgentFree(PySmlDevInfAgent *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlDevInfAgentFree(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfAgentSendDevInf(PySmlDevInfAgent *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlSession *session2;
    SmlSession *session_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"session", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlSession_Type, &session2)) {
        return NULL;
    }
    session_ptr = (session2 ? session2->obj : NULL);
    retval = smlDevInfAgentSendDevInf(self->obj, session_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfAgentRegisterSession(PySmlDevInfAgent *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlManager *manager2;
    SmlManager *manager_ptr;
    PySmlSession *session2;
    SmlSession *session_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"manager", "session", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PySmlManager_Type, &manager2, &PySmlSession_Type, &session2)) {
        return NULL;
    }
    manager_ptr = (manager2 ? manager2->obj : NULL);
    session_ptr = (session2 ? session2->obj : NULL);
    retval = smlDevInfAgentRegisterSession(self->obj, manager_ptr, session_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfAgentRequestDevInf(PySmlDevInfAgent *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlSession *session2;
    SmlSession *session_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"session", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlSession_Type, &session2)) {
        return NULL;
    }
    session_ptr = (session2 ? session2->obj : NULL);
    retval = smlDevInfAgentRequestDevInf(self->obj, session_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

static PyMethodDef PySmlDevInfAgent_methods[] = {
    {(char *) "SetDevInf", (PyCFunction) _wrap_syncmlsmlDevInfAgentSetDevInf, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Register", (PyCFunction) _wrap_syncmlsmlDevInfAgentRegister, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Free", (PyCFunction) _wrap_syncmlsmlDevInfAgentFree, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SendDevInf", (PyCFunction) _wrap_syncmlsmlDevInfAgentSendDevInf, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RegisterSession", (PyCFunction) _wrap_syncmlsmlDevInfAgentRegisterSession, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RequestDevInf", (PyCFunction) _wrap_syncmlsmlDevInfAgentRequestDevInf, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlDevInfAgent__tp_dealloc(PySmlDevInfAgent *self)
{
    if (self->obj) {
    SmlDevInfAgent *tmp = self->obj;
    self->obj = NULL;
    smlDevInfAgentFree(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlDevInfAgent__tp_richcompare (PySmlDevInfAgent *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlDevInfAgent_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlDevInfAgent",            /* tp_name */
    sizeof(PySmlDevInfAgent),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlDevInfAgent__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlDevInfAgent__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlDevInfAgent_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlDevInfAgent__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlAnchor__tp_init(PySmlAnchor *self, PyObject *args, PyObject *kwargs)
{
    const char *last2;
    const char *next2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"last", "next", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ss", (char **) keywords, &last2, &next2)) {
        return -1;
    }
    self->obj = smlAnchorNew(last2, next2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}


PyObject *
_wrap_syncmlsmlAnchorFree(PySmlAnchor *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlAnchorFree(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PySmlAnchor_methods[] = {
    {(char *) "Free", (PyCFunction) _wrap_syncmlsmlAnchorFree, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlAnchor__tp_dealloc(PySmlAnchor *self)
{
    if (self->obj) {
    SmlAnchor *tmp = self->obj;
    self->obj = NULL;
    smlAnchorFree(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlAnchor__tp_richcompare (PySmlAnchor *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlAnchor_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlAnchor",            /* tp_name */
    sizeof(PySmlAnchor),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlAnchor__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlAnchor__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlAnchor_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlAnchor__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlDevInfDataStore__tp_init(PySmlDevInfDataStore *self, PyObject *args, PyObject *kwargs)
{
    const char *sourceRef2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"sourceRef", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &sourceRef2)) {
        return -1;
    }
    self->obj = smlDevInfDataStoreNew(sourceRef2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}


PyObject *
_wrap_syncmlsmlDevInfDataStoreSetSyncCap(PySmlDevInfDataStore *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlDevInfSyncCap cap2;
    SmlBool supported2;
    const char *keywords[] = {"cap", "supported", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ii", (char **) keywords, &cap2, &supported2)) {
        return NULL;
    }
    smlDevInfDataStoreSetSyncCap(self->obj, cap2, supported2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfDataStoreSetDisplayName(PySmlDevInfDataStore *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *displayName2;
    const char *keywords[] = {"displayName", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &displayName2)) {
        return NULL;
    }
    smlDevInfDataStoreSetDisplayName(self->obj, displayName2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfDataStoreGetSourceRef(PySmlDevInfDataStore *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfDataStoreGetSourceRef(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}



PyObject *
_wrap_syncmlsmlDevInfDataStoreAddTx(PySmlDevInfDataStore *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlDevInfContentType *ct2;
    SmlDevInfContentType *ct_ptr;
    const char *keywords[] = {"ct", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlDevInfContentType_Type, &ct2)) {
        return NULL;
    }
    ct_ptr = (ct2 ? ct2->obj : NULL);
    smlDevInfDataStoreAddTx(self->obj, ct_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfDataStoreSetSourceRef(PySmlDevInfDataStore *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *sourceref2;
    const char *keywords[] = {"sourceref", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &sourceref2)) {
        return NULL;
    }
    smlDevInfDataStoreSetSourceRef(self->obj, sourceref2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfDataStoreGetDisplayName(PySmlDevInfDataStore *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfDataStoreGetDisplayName(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfDataStoreNumTx(PySmlDevInfDataStore *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfDataStoreNumTx(self->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfDataStoreGetSyncCap(PySmlDevInfDataStore *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    SmlDevInfSyncCap cap2;
    const char *keywords[] = {"cap", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &cap2)) {
        return NULL;
    }
    retval = smlDevInfDataStoreGetSyncCap(self->obj, cap2);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfDataStoreUnref(PySmlDevInfDataStore *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlDevInfDataStoreUnref(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfDataStoreSetMemory(PySmlDevInfDataStore *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool shared2;
    unsigned int maxid2;
    unsigned int maxmem2;
    const char *keywords[] = {"shared", "maxid", "maxmem", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iII", (char **) keywords, &shared2, &maxid2, &maxmem2)) {
        return NULL;
    }
    smlDevInfDataStoreSetMemory(self->obj, shared2, maxid2, maxmem2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_syncmlsmlDevInfDataStoreNumRx(PySmlDevInfDataStore *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfDataStoreNumRx(self->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfDataStoreSetRxPref(PySmlDevInfDataStore *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *contenttype2;
    const char *version2;
    const char *keywords[] = {"contenttype", "version", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ss", (char **) keywords, &contenttype2, &version2)) {
        return NULL;
    }
    smlDevInfDataStoreSetRxPref(self->obj, contenttype2, version2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfDataStoreSetTxPref(PySmlDevInfDataStore *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *contenttype2;
    const char *version2;
    const char *keywords[] = {"contenttype", "version", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ss", (char **) keywords, &contenttype2, &version2)) {
        return NULL;
    }
    smlDevInfDataStoreSetTxPref(self->obj, contenttype2, version2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfDataStoreAddRx(PySmlDevInfDataStore *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlDevInfContentType *ct2;
    SmlDevInfContentType *ct_ptr;
    const char *keywords[] = {"ct", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlDevInfContentType_Type, &ct2)) {
        return NULL;
    }
    ct_ptr = (ct2 ? ct2->obj : NULL);
    smlDevInfDataStoreAddRx(self->obj, ct_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PySmlDevInfDataStore_methods[] = {
    {(char *) "SetSyncCap", (PyCFunction) _wrap_syncmlsmlDevInfDataStoreSetSyncCap, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDisplayName", (PyCFunction) _wrap_syncmlsmlDevInfDataStoreSetDisplayName, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetSourceRef", (PyCFunction) _wrap_syncmlsmlDevInfDataStoreGetSourceRef, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddTx", (PyCFunction) _wrap_syncmlsmlDevInfDataStoreAddTx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetSourceRef", (PyCFunction) _wrap_syncmlsmlDevInfDataStoreSetSourceRef, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDisplayName", (PyCFunction) _wrap_syncmlsmlDevInfDataStoreGetDisplayName, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NumTx", (PyCFunction) _wrap_syncmlsmlDevInfDataStoreNumTx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetSyncCap", (PyCFunction) _wrap_syncmlsmlDevInfDataStoreGetSyncCap, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Unref", (PyCFunction) _wrap_syncmlsmlDevInfDataStoreUnref, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetMemory", (PyCFunction) _wrap_syncmlsmlDevInfDataStoreSetMemory, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NumRx", (PyCFunction) _wrap_syncmlsmlDevInfDataStoreNumRx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetRxPref", (PyCFunction) _wrap_syncmlsmlDevInfDataStoreSetRxPref, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetTxPref", (PyCFunction) _wrap_syncmlsmlDevInfDataStoreSetTxPref, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddRx", (PyCFunction) _wrap_syncmlsmlDevInfDataStoreAddRx, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlDevInfDataStore__tp_dealloc(PySmlDevInfDataStore *self)
{
    if (self->obj) {
    SmlDevInfDataStore *tmp = self->obj;
    self->obj = NULL;
    smlDevInfDataStoreUnref(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlDevInfDataStore__tp_richcompare (PySmlDevInfDataStore *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlDevInfDataStore_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlDevInfDataStore",            /* tp_name */
    sizeof(PySmlDevInfDataStore),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlDevInfDataStore__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlDevInfDataStore__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlDevInfDataStore_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlDevInfDataStore__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlDevInfPropParam__tp_init(PySmlDevInfPropParam *self, PyObject *args, PyObject *kwargs)
{
    SmlError *error2 = NULL;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return -1;
    }
    self->obj = smlDevInfNewPropParam(&error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}


PyObject *
_wrap_syncmlsmlDevInfPropParamGetNthValEnum(PySmlDevInfPropParam *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    char *retval;
    unsigned int n2;
    const char *keywords[] = {"n", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n2)) {
        return NULL;
    }
    retval = smlDevInfPropParamGetNthValEnum(self->obj, n2);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropParamGetParamName(PySmlDevInfPropParam *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfPropParamGetParamName(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropParamSetDisplayName(PySmlDevInfPropParam *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *displayName2;
    const char *keywords[] = {"displayName", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &displayName2)) {
        return NULL;
    }
    smlDevInfPropParamSetDisplayName(self->obj, displayName2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropParamSetDataType(PySmlDevInfPropParam *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *dataType2;
    const char *keywords[] = {"dataType", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &dataType2)) {
        return NULL;
    }
    smlDevInfPropParamSetDataType(self->obj, dataType2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropParamNumValEnums(PySmlDevInfPropParam *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfPropParamNumValEnums(self->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropParamSetParamName(PySmlDevInfPropParam *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *paramName2;
    const char *keywords[] = {"paramName", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &paramName2)) {
        return NULL;
    }
    smlDevInfPropParamSetParamName(self->obj, paramName2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropParamAddValEnum(PySmlDevInfPropParam *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *valEnum2;
    const char *keywords[] = {"valEnum", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &valEnum2)) {
        return NULL;
    }
    smlDevInfPropParamAddValEnum(self->obj, valEnum2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropParamGetDisplayName(PySmlDevInfPropParam *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfPropParamGetDisplayName(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropParamGetDataType(PySmlDevInfPropParam *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfPropParamGetDataType(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}

static PyMethodDef PySmlDevInfPropParam_methods[] = {
    {(char *) "GetNthValEnum", (PyCFunction) _wrap_syncmlsmlDevInfPropParamGetNthValEnum, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetParamName", (PyCFunction) _wrap_syncmlsmlDevInfPropParamGetParamName, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDisplayName", (PyCFunction) _wrap_syncmlsmlDevInfPropParamSetDisplayName, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDataType", (PyCFunction) _wrap_syncmlsmlDevInfPropParamSetDataType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NumValEnums", (PyCFunction) _wrap_syncmlsmlDevInfPropParamNumValEnums, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetParamName", (PyCFunction) _wrap_syncmlsmlDevInfPropParamSetParamName, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddValEnum", (PyCFunction) _wrap_syncmlsmlDevInfPropParamAddValEnum, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDisplayName", (PyCFunction) _wrap_syncmlsmlDevInfPropParamGetDisplayName, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDataType", (PyCFunction) _wrap_syncmlsmlDevInfPropParamGetDataType, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlDevInfPropParam__tp_dealloc(PySmlDevInfPropParam *self)
{
    if (self->obj) {
    SmlDevInfPropParam *tmp = self->obj;
    self->obj = NULL;
    HACKFree(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlDevInfPropParam__tp_richcompare (PySmlDevInfPropParam *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlDevInfPropParam_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlDevInfPropParam",            /* tp_name */
    sizeof(PySmlDevInfPropParam),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlDevInfPropParam__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlDevInfPropParam__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlDevInfPropParam_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlDevInfPropParam__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlDevInfContentType__tp_init(PySmlDevInfContentType *self, PyObject *args, PyObject *kwargs)
{
    const char *cttype2;
    const char *verct2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"cttype", "verct", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ss", (char **) keywords, &cttype2, &verct2)) {
        return -1;
    }
    self->obj = smlDevInfNewContentType(cttype2, verct2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}


PyObject *
_wrap_syncmlsmlDevInfContentTypeGetCTType(PySmlDevInfContentType *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfContentTypeGetCTType(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfContentTypeGetVerCT(PySmlDevInfContentType *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfContentTypeGetVerCT(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}

static PyMethodDef PySmlDevInfContentType_methods[] = {
    {(char *) "GetCTType", (PyCFunction) _wrap_syncmlsmlDevInfContentTypeGetCTType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetVerCT", (PyCFunction) _wrap_syncmlsmlDevInfContentTypeGetVerCT, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlDevInfContentType__tp_dealloc(PySmlDevInfContentType *self)
{
    if (self->obj) {
    SmlDevInfContentType *tmp = self->obj;
    self->obj = NULL;
    HACKFree(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlDevInfContentType__tp_richcompare (PySmlDevInfContentType *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlDevInfContentType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlDevInfContentType",            /* tp_name */
    sizeof(PySmlDevInfContentType),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlDevInfContentType__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlDevInfContentType__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlDevInfContentType_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlDevInfContentType__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlDevInfCTCap__tp_init(PySmlDevInfCTCap *self, PyObject *args, PyObject *kwargs)
{
    SmlError *error2 = NULL;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return -1;
    }
    self->obj = smlDevInfNewCTCap(&error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}


PyObject *
_wrap_syncmlsmlDevInfCTCapAddProperty(PySmlDevInfCTCap *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlDevInfProperty *property2;
    SmlDevInfProperty *property_ptr;
    const char *keywords[] = {"property", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlDevInfProperty_Type, &property2)) {
        return NULL;
    }
    property_ptr = (property2 ? property2->obj : NULL);
    smlDevInfCTCapAddProperty(self->obj, property_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfCTCapNumProperties(PySmlDevInfCTCap *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfCTCapNumProperties(self->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfCTCapSetCTType(PySmlDevInfCTCap *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *cttype2;
    const char *keywords[] = {"cttype", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &cttype2)) {
        return NULL;
    }
    smlDevInfCTCapSetCTType(self->obj, cttype2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfCTCapGetVerCT(PySmlDevInfCTCap *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfCTCapGetVerCT(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfCTCapGetCTType(PySmlDevInfCTCap *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfCTCapGetCTType(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}



PyObject *
_wrap_syncmlsmlDevInfCTCapSetVerCT(PySmlDevInfCTCap *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *verct2;
    const char *keywords[] = {"verct", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &verct2)) {
        return NULL;
    }
    smlDevInfCTCapSetVerCT(self->obj, verct2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PySmlDevInfCTCap_methods[] = {
    {(char *) "AddProperty", (PyCFunction) _wrap_syncmlsmlDevInfCTCapAddProperty, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NumProperties", (PyCFunction) _wrap_syncmlsmlDevInfCTCapNumProperties, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetCTType", (PyCFunction) _wrap_syncmlsmlDevInfCTCapSetCTType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetVerCT", (PyCFunction) _wrap_syncmlsmlDevInfCTCapGetVerCT, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetCTType", (PyCFunction) _wrap_syncmlsmlDevInfCTCapGetCTType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetVerCT", (PyCFunction) _wrap_syncmlsmlDevInfCTCapSetVerCT, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlDevInfCTCap__tp_dealloc(PySmlDevInfCTCap *self)
{
    if (self->obj) {
    SmlDevInfCTCap *tmp = self->obj;
    self->obj = NULL;
    HACKFree(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlDevInfCTCap__tp_richcompare (PySmlDevInfCTCap *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlDevInfCTCap_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlDevInfCTCap",            /* tp_name */
    sizeof(PySmlDevInfCTCap),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlDevInfCTCap__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlDevInfCTCap__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlDevInfCTCap_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlDevInfCTCap__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlDevInf__tp_init(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    const char *devid2;
    SmlDevInfDevTyp devtyp2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"devid", "devtyp", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "si", (char **) keywords, &devid2, &devtyp2)) {
        return -1;
    }
    self->obj = smlDevInfNew(devid2, devtyp2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}


PyObject *
_wrap_syncmlsmlDevInfSetFirmwareVersion(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *firmwareVersion2;
    const char *keywords[] = {"firmwareVersion", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &firmwareVersion2)) {
        return NULL;
    }
    smlDevInfSetFirmwareVersion(self->obj, firmwareVersion2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfSupportsUTC(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfSupportsUTC(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfGetModel(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfGetModel(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfGetOEM(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfGetOEM(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfSupportsLargeObjs(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfSupportsLargeObjs(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}



PyObject *
_wrap_syncmlsmlDevInfSetSoftwareVersion(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *softwareVersion2;
    const char *keywords[] = {"softwareVersion", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &softwareVersion2)) {
        return NULL;
    }
    smlDevInfSetSoftwareVersion(self->obj, softwareVersion2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfSupportsNumberOfChanges(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfSupportsNumberOfChanges(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfConfigureSession(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlSession *session2;
    SmlSession *session_ptr;
    const char *keywords[] = {"session", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlSession_Type, &session2)) {
        return NULL;
    }
    session_ptr = (session2 ? session2->obj : NULL);
    smlDevInfConfigureSession(self->obj, session_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfAddDataStore(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlDevInfDataStore *datastore2;
    SmlDevInfDataStore *datastore_ptr;
    const char *keywords[] = {"datastore", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlDevInfDataStore_Type, &datastore2)) {
        return NULL;
    }
    datastore_ptr = (datastore2 ? datastore2->obj : NULL);
    smlDevInfAddDataStore(self->obj, datastore_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfGetDeviceID(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfGetDeviceID(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfSetDeviceType(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlDevInfDevTyp devtyp2;
    const char *keywords[] = {"devtyp", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &devtyp2)) {
        return NULL;
    }
    smlDevInfSetDeviceType(self->obj, devtyp2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfSetSupportsLargeObjs(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool supports2;
    const char *keywords[] = {"supports", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &supports2)) {
        return NULL;
    }
    smlDevInfSetSupportsLargeObjs(self->obj, supports2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfNumCTCaps(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfNumCTCaps(self->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfGetManufacturer(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfGetManufacturer(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfGetHardwareVersion(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfGetHardwareVersion(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfGetSoftwareVersion(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfGetSoftwareVersion(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfAppendCTCap(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlDevInfCTCap *ctcap2;
    SmlDevInfCTCap *ctcap_ptr;
    const char *keywords[] = {"ctcap", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlDevInfCTCap_Type, &ctcap2)) {
        return NULL;
    }
    ctcap_ptr = (ctcap2 ? ctcap2->obj : NULL);
    smlDevInfAppendCTCap(self->obj, ctcap_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_syncmlsmlDevInfUnref(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlDevInfUnref(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfNumDataStores(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfNumDataStores(self->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfSetManufacturer(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *man2;
    const char *keywords[] = {"man", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &man2)) {
        return NULL;
    }
    smlDevInfSetManufacturer(self->obj, man2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfSetHardwareVersion(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *hardwareVersion2;
    const char *keywords[] = {"hardwareVersion", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &hardwareVersion2)) {
        return NULL;
    }
    smlDevInfSetHardwareVersion(self->obj, hardwareVersion2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfGetFirmwareVersion(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfGetFirmwareVersion(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfSetSupportsUTC(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool supports2;
    const char *keywords[] = {"supports", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &supports2)) {
        return NULL;
    }
    smlDevInfSetSupportsUTC(self->obj, supports2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_syncmlsmlDevInfGetDeviceType(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlDevInfDevTyp retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfGetDeviceType(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfSetSupportsNumberOfChanges(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool supports2;
    const char *keywords[] = {"supports", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &supports2)) {
        return NULL;
    }
    smlDevInfSetSupportsNumberOfChanges(self->obj, supports2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfSetOEM(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *oem2;
    const char *keywords[] = {"oem", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &oem2)) {
        return NULL;
    }
    smlDevInfSetOEM(self->obj, oem2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfSetDeviceID(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *devid2;
    const char *keywords[] = {"devid", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &devid2)) {
        return NULL;
    }
    smlDevInfSetDeviceID(self->obj, devid2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfSetModel(PySmlDevInf *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *model2;
    const char *keywords[] = {"model", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &model2)) {
        return NULL;
    }
    smlDevInfSetModel(self->obj, model2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PySmlDevInf_methods[] = {
    {(char *) "SetFirmwareVersion", (PyCFunction) _wrap_syncmlsmlDevInfSetFirmwareVersion, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SupportsUTC", (PyCFunction) _wrap_syncmlsmlDevInfSupportsUTC, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetModel", (PyCFunction) _wrap_syncmlsmlDevInfGetModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetOEM", (PyCFunction) _wrap_syncmlsmlDevInfGetOEM, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SupportsLargeObjs", (PyCFunction) _wrap_syncmlsmlDevInfSupportsLargeObjs, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetSoftwareVersion", (PyCFunction) _wrap_syncmlsmlDevInfSetSoftwareVersion, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SupportsNumberOfChanges", (PyCFunction) _wrap_syncmlsmlDevInfSupportsNumberOfChanges, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "ConfigureSession", (PyCFunction) _wrap_syncmlsmlDevInfConfigureSession, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddDataStore", (PyCFunction) _wrap_syncmlsmlDevInfAddDataStore, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDeviceID", (PyCFunction) _wrap_syncmlsmlDevInfGetDeviceID, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDeviceType", (PyCFunction) _wrap_syncmlsmlDevInfSetDeviceType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetSupportsLargeObjs", (PyCFunction) _wrap_syncmlsmlDevInfSetSupportsLargeObjs, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NumCTCaps", (PyCFunction) _wrap_syncmlsmlDevInfNumCTCaps, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetManufacturer", (PyCFunction) _wrap_syncmlsmlDevInfGetManufacturer, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetHardwareVersion", (PyCFunction) _wrap_syncmlsmlDevInfGetHardwareVersion, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetSoftwareVersion", (PyCFunction) _wrap_syncmlsmlDevInfGetSoftwareVersion, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AppendCTCap", (PyCFunction) _wrap_syncmlsmlDevInfAppendCTCap, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Unref", (PyCFunction) _wrap_syncmlsmlDevInfUnref, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NumDataStores", (PyCFunction) _wrap_syncmlsmlDevInfNumDataStores, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetManufacturer", (PyCFunction) _wrap_syncmlsmlDevInfSetManufacturer, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetHardwareVersion", (PyCFunction) _wrap_syncmlsmlDevInfSetHardwareVersion, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetFirmwareVersion", (PyCFunction) _wrap_syncmlsmlDevInfGetFirmwareVersion, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetSupportsUTC", (PyCFunction) _wrap_syncmlsmlDevInfSetSupportsUTC, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDeviceType", (PyCFunction) _wrap_syncmlsmlDevInfGetDeviceType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetSupportsNumberOfChanges", (PyCFunction) _wrap_syncmlsmlDevInfSetSupportsNumberOfChanges, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetOEM", (PyCFunction) _wrap_syncmlsmlDevInfSetOEM, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDeviceID", (PyCFunction) _wrap_syncmlsmlDevInfSetDeviceID, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetModel", (PyCFunction) _wrap_syncmlsmlDevInfSetModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlDevInf__tp_dealloc(PySmlDevInf *self)
{
    if (self->obj) {
    SmlDevInf *tmp = self->obj;
    self->obj = NULL;
    smlDevInfUnref(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlDevInf__tp_richcompare (PySmlDevInf *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlDevInf_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlDevInf",            /* tp_name */
    sizeof(PySmlDevInf),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlDevInf__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlDevInf__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlDevInf_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlDevInf__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlChal__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'SmlChal' cannot be constructed ()");
    return -1;
}


PyObject *
_wrap_syncmlsmlChalUnref(PySmlChal *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlChalUnref(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlChalRef(PySmlChal *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlChalRef(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlChalFree(PySmlChal *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlChalFree(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PySmlChal_methods[] = {
    {(char *) "Unref", (PyCFunction) _wrap_syncmlsmlChalUnref, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Ref", (PyCFunction) _wrap_syncmlsmlChalRef, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Free", (PyCFunction) _wrap_syncmlsmlChalFree, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlChal__tp_dealloc(PySmlChal *self)
{
    
    if (self->obj) {
    SmlChal *tmp = self->obj;
    self->obj = NULL;
    smlChalUnref(tmp);
}
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlChal__tp_richcompare (PySmlChal *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlChal_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlChal",            /* tp_name */
    sizeof(PySmlChal),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlChal__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlChal__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlChal_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlChal__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlNotification__tp_init(PySmlNotification *self, PyObject *args, PyObject *kwargs)
{
    SmlNotificationVersion version2;
    SmlNotificationUIMode mode2;
    SmlNotificationInitiator init2;
    unsigned int sessionID2;
    const char *identifier2;
    const char *target2;
    SmlMimeType type2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"version", "mode", "init", "sessionID", "identifier", "target", "type", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iiiIssi", (char **) keywords, &version2, &mode2, &init2, &sessionID2, &identifier2, &target2, &type2)) {
        return -1;
    }
    self->obj = smlNotificationNew(version2, mode2, init2, sessionID2, identifier2, target2, type2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}


PyObject *
_wrap_syncmlsmlNotificationGetMode(PySmlNotification *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlNotificationUIMode retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlNotificationGetMode(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlNotificationGetSessionID(PySmlNotification *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlNotificationGetSessionID(self->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_syncmlsmlNotificationGetInitiator(PySmlNotification *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlNotificationInitiator retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlNotificationGetInitiator(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlNotificationFree(PySmlNotification *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlNotificationFree(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlNotificationNumAlerts(PySmlNotification *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlNotificationNumAlerts(self->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_syncmlsmlNotificationSend(PySmlNotification *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlTransport *tsp2;
    SmlTransport *tsp_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"tsp", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlTransport_Type, &tsp2)) {
        return NULL;
    }
    tsp_ptr = (tsp2 ? tsp2->obj : NULL);
    retval = smlNotificationSend(self->obj, tsp_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlNotificationGetIdentifier(PySmlNotification *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlNotificationGetIdentifier(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlNotificationGetVersion(PySmlNotification *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlNotificationVersion retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlNotificationGetVersion(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlNotificationSetCred(PySmlNotification *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlCred *cred2;
    SmlCred *cred_ptr;
    const char *keywords[] = {"cred", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlCred_Type, &cred2)) {
        return NULL;
    }
    cred_ptr = (cred2 ? cred2->obj : NULL);
    smlNotificationSetCred(self->obj, cred_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlNotificationNewAlert(PySmlNotification *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    SmlAlertType type2;
    const char *contenttype2;
    const char *serverURI2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"type", "contenttype", "serverURI", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iss", (char **) keywords, &type2, &contenttype2, &serverURI2)) {
        return NULL;
    }
    retval = smlNotificationNewAlert(self->obj, type2, contenttype2, serverURI2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlNotificationSetManager(PySmlNotification *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlManager *manager2;
    SmlManager *manager_ptr;
    const char *keywords[] = {"manager", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlManager_Type, &manager2)) {
        return NULL;
    }
    manager_ptr = (manager2 ? manager2->obj : NULL);
    smlNotificationSetManager(self->obj, manager_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PySmlNotification_methods[] = {
    {(char *) "GetMode", (PyCFunction) _wrap_syncmlsmlNotificationGetMode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetSessionID", (PyCFunction) _wrap_syncmlsmlNotificationGetSessionID, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInitiator", (PyCFunction) _wrap_syncmlsmlNotificationGetInitiator, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Free", (PyCFunction) _wrap_syncmlsmlNotificationFree, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NumAlerts", (PyCFunction) _wrap_syncmlsmlNotificationNumAlerts, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Send", (PyCFunction) _wrap_syncmlsmlNotificationSend, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetIdentifier", (PyCFunction) _wrap_syncmlsmlNotificationGetIdentifier, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetVersion", (PyCFunction) _wrap_syncmlsmlNotificationGetVersion, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetCred", (PyCFunction) _wrap_syncmlsmlNotificationSetCred, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NewAlert", (PyCFunction) _wrap_syncmlsmlNotificationNewAlert, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetManager", (PyCFunction) _wrap_syncmlsmlNotificationSetManager, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlNotification__tp_dealloc(PySmlNotification *self)
{
    if (self->obj) {
    SmlNotification *tmp = self->obj;
    self->obj = NULL;
    smlNotificationFree(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlNotification__tp_richcompare (PySmlNotification *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlNotification_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlNotification",            /* tp_name */
    sizeof(PySmlNotification),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlNotification__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlNotification__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlNotification_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlNotification__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlMapItem__tp_init(PySmlMapItem *self, PyObject *args, PyObject *kwargs)
{
    const char *uid2;
    const char *newuid2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"uid", "newuid", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ss", (char **) keywords, &uid2, &newuid2)) {
        return -1;
    }
    self->obj = smlMapItemNew(uid2, newuid2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}


PyObject *
_wrap_syncmlsmlMapItemUnref(PySmlMapItem *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlMapItemUnref(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PySmlMapItem_methods[] = {
    {(char *) "Unref", (PyCFunction) _wrap_syncmlsmlMapItemUnref, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlMapItem__tp_dealloc(PySmlMapItem *self)
{
    if (self->obj) {
    SmlMapItem *tmp = self->obj;
    self->obj = NULL;
    smlMapItemUnref(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlMapItem__tp_richcompare (PySmlMapItem *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlMapItem_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlMapItem",            /* tp_name */
    sizeof(PySmlMapItem),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlMapItem__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlMapItem__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlMapItem_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlMapItem__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlHeader__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'SmlHeader' cannot be constructed ()");
    return -1;
}


PyObject *
_wrap_syncmlsmlHeaderFree(PySmlHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlHeaderFree(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PySmlHeader_methods[] = {
    {(char *) "Free", (PyCFunction) _wrap_syncmlsmlHeaderFree, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlHeader__tp_dealloc(PySmlHeader *self)
{
    
    if (self->obj) {
    SmlHeader *tmp = self->obj;
    self->obj = NULL;
    smlHeaderFree(tmp);
}
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlHeader__tp_richcompare (PySmlHeader *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlHeader_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlHeader",            /* tp_name */
    sizeof(PySmlHeader),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlHeader__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlHeader__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlHeader_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlHeader__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlManager__tp_init(PySmlManager *self, PyObject *args, PyObject *kwargs)
{
    PySmlTransport *tsp2;
    SmlTransport *tsp_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"tsp", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlTransport_Type, &tsp2)) {
        return -1;
    }
    tsp_ptr = (tsp2 ? tsp2->obj : NULL);
    self->obj = smlManagerNew(tsp_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}




PyObject *
_wrap_smlManagerObjectRegister(PySmlManager *self, PyObject *args, PyObject *kwargs, PyObject **return_exception) 
{
    PyObject *exc_type, *traceback;
    PyObject *py_retval;
    SmlBool retval;
    SmlCommandType type;
    PySmlSession *session;
    PySmlLocation *location;
    PySmlLocation *source;
    char const *contentType;
    PyObject *callback;
    PyObject *childCallback;
    SmlError *error2 = NULL;

    const char *keywords[] = {"type", "session", "location", "source", "contentType", "callback", "childCallback", NULL};
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iO!O!O!sO!O!", (char **) keywords, &type, &PySmlSession_Type, &session, &PySmlLocation_Type, &location, &PySmlLocation_Type, &source, &contentType, &PyFunction_Type, &callback, &PyFunction_Type, &childCallback)) {
        PyErr_SetString(PyExc_TypeError, "Incorrect Arguments");
        goto error;
    }
    retval = smlManagerObjectRegister(self->obj, type, session->obj, location->obj, source->obj, contentType, _SmlCommandCb, /*_SmlCommandCb*/NULL, (void *)callback, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        goto error;
    }
    py_retval = Py_BuildValue("i", retval);
    return py_retval;
error:
    PyErr_Fetch(&exc_type, return_exception, &traceback);
    Py_XDECREF(exc_type);

    Py_XDECREF(traceback);
    return NULL;
}


PyObject * _wrap_PySmlManager_ObjectRegister(PySmlManager *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[1] = {0,};
    retval = _wrap_smlManagerObjectRegister(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    error_list = PyList_New(1);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_syncmlsmlManagerQuit(PySmlManager *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlManagerQuit(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlManagerRun(PySmlManager *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlManagerRun(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlManagerDispatchHeader(PySmlManager *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlSession *session2;
    SmlSession *session_ptr;
    PySmlHeader *header2;
    SmlHeader *header_ptr;
    PySmlCred *cred2;
    SmlCred *cred_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"session", "header", "cred", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PySmlSession_Type, &session2, &PySmlHeader_Type, &header2, &PySmlCred_Type, &cred2)) {
        return NULL;
    }
    session_ptr = (session2 ? session2->obj : NULL);
    header_ptr = (header2 ? header2->obj : NULL);
    cred_ptr = (cred2 ? cred2->obj : NULL);
    retval = smlManagerDispatchHeader(self->obj, session_ptr, header_ptr, cred_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlManagerStop(PySmlManager *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlManagerStop(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlManagerDispatch(PySmlManager *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlManagerDispatch(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlManagerFree(PySmlManager *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlManagerFree(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlManagerStart(PySmlManager *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    SmlError *error2 = NULL;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlManagerStart(self->obj, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}




PyObject *
_wrap_smlManagerSetEventCallback(PySmlManager *self, PyObject *args, PyObject **return_exception)    
{
    PyObject *exc_type, *traceback;
    PyObject *py_callback;
    SmlManager *manager;

    if (PyTuple_GET_SIZE(args) < 1) {
        PyErr_SetString(PyExc_TypeError, "Callback required");
        goto error;
    }
    py_callback = PyTuple_GET_ITEM(args, 0);

    if (!PyCallable_Check(py_callback)) {
        PyErr_SetString(PyExc_TypeError, "Callback should be callable");
        goto error;
    }
    smlManagerSetEventCallback(self->obj, _SmlManagerEventCb, (void *)py_callback);

    Py_INCREF(Py_None);
    return Py_None;

error:
    PyErr_Fetch(&exc_type, return_exception, &traceback);
    Py_XDECREF(exc_type);

    Py_XDECREF(traceback);
    return NULL;
}


PyObject * _wrap_PySmlManager_SetEventCallback(PySmlManager *self, PyObject *args)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[1] = {0,};
    retval = _wrap_smlManagerSetEventCallback(self, args, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    error_list = PyList_New(1);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_syncmlsmlManagerDispatchCommand(PySmlManager *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlSession *session2;
    SmlSession *session_ptr;
    PySmlCommand *cmd2;
    SmlCommand *cmd_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"session", "cmd", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PySmlSession_Type, &session2, &PySmlCommand_Type, &cmd2)) {
        return NULL;
    }
    session_ptr = (session2 ? session2->obj : NULL);
    cmd_ptr = (cmd2 ? cmd2->obj : NULL);
    retval = smlManagerDispatchCommand(self->obj, session_ptr, cmd_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlManagerSessionAdd(PySmlManager *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlSession *session2;
    SmlSession *session_ptr;
    PySmlLink *link2;
    SmlLink *link_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"session", "link", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PySmlSession_Type, &session2, &PySmlLink_Type, &link2)) {
        return NULL;
    }
    session_ptr = (session2 ? session2->obj : NULL);
    link_ptr = (link2 ? link2->obj : NULL);
    retval = smlManagerSessionAdd(self->obj, session_ptr, link_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlManagerSessionRemove(PySmlManager *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlSession *session2;
    SmlSession *session_ptr;
    const char *keywords[] = {"session", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlSession_Type, &session2)) {
        return NULL;
    }
    session_ptr = (session2 ? session2->obj : NULL);
    smlManagerSessionRemove(self->obj, session_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlManagerCheck(PySmlManager *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlManagerCheck(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlManagerDispatchChildCommand(PySmlManager *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlSession *session2;
    SmlSession *session_ptr;
    PySmlCommand *parent2;
    SmlCommand *parent_ptr;
    PySmlCommand *cmd2;
    SmlCommand *cmd_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"session", "parent", "cmd", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PySmlSession_Type, &session2, &PySmlCommand_Type, &parent2, &PySmlCommand_Type, &cmd2)) {
        return NULL;
    }
    session_ptr = (session2 ? session2->obj : NULL);
    parent_ptr = (parent2 ? parent2->obj : NULL);
    cmd_ptr = (cmd2 ? cmd2->obj : NULL);
    retval = smlManagerDispatchChildCommand(self->obj, session_ptr, parent_ptr, cmd_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

static PyMethodDef PySmlManager_methods[] = {
    {(char *) "ObjectRegister", (PyCFunction) _wrap_PySmlManager_ObjectRegister, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Quit", (PyCFunction) _wrap_syncmlsmlManagerQuit, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Run", (PyCFunction) _wrap_syncmlsmlManagerRun, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "DispatchHeader", (PyCFunction) _wrap_syncmlsmlManagerDispatchHeader, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Stop", (PyCFunction) _wrap_syncmlsmlManagerStop, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Dispatch", (PyCFunction) _wrap_syncmlsmlManagerDispatch, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Free", (PyCFunction) _wrap_syncmlsmlManagerFree, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Start", (PyCFunction) _wrap_syncmlsmlManagerStart, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetEventCallback", (PyCFunction) _wrap_PySmlManager_SetEventCallback, METH_VARARGS, NULL },
    {(char *) "DispatchCommand", (PyCFunction) _wrap_syncmlsmlManagerDispatchCommand, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SessionAdd", (PyCFunction) _wrap_syncmlsmlManagerSessionAdd, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SessionRemove", (PyCFunction) _wrap_syncmlsmlManagerSessionRemove, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Check", (PyCFunction) _wrap_syncmlsmlManagerCheck, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "DispatchChildCommand", (PyCFunction) _wrap_syncmlsmlManagerDispatchChildCommand, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlManager__tp_dealloc(PySmlManager *self)
{
    if (self->obj) {
    SmlManager *tmp = self->obj;
    self->obj = NULL;
    smlManagerFree(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlManager__tp_richcompare (PySmlManager *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlManager_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlManager",            /* tp_name */
    sizeof(PySmlManager),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlManager__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlManager__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlManager_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlManager__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlLocation__tp_init(PySmlLocation *self, PyObject *args, PyObject *kwargs)
{
    const char *locURI2;
    const char *locName2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"locURI", "locName", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ss", (char **) keywords, &locURI2, &locName2)) {
        return -1;
    }
    self->obj = smlLocationNew(locURI2, locName2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}


PyObject *
_wrap_syncmlsmlLocationCompare(PySmlLocation *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlLocation *object2;
    SmlLocation *object_ptr;
    PySmlLocation *urlroot2;
    SmlLocation *urlroot_ptr;
    PySmlLocation *url2;
    SmlLocation *url_ptr;
    const char *keywords[] = {"object", "urlroot", "url", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PySmlLocation_Type, &object2, &PySmlLocation_Type, &urlroot2, &PySmlLocation_Type, &url2)) {
        return NULL;
    }
    object_ptr = (object2 ? object2->obj : NULL);
    urlroot_ptr = (urlroot2 ? urlroot2->obj : NULL);
    url_ptr = (url2 ? url2->obj : NULL);
    retval = smlLocationCompare(self->obj, object_ptr, urlroot_ptr, url_ptr);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlLocationGetURI(PySmlLocation *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlLocationGetURI(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlLocationSetName(PySmlLocation *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *name2;
    const char *keywords[] = {"name", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &name2)) {
        return NULL;
    }
    smlLocationSetName(self->obj, name2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlLocationGetName(PySmlLocation *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlLocationGetName(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlLocationUnref(PySmlLocation *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlLocationUnref(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlLocationCopy(PySmlLocation *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlLocation *target2;
    SmlLocation *target_ptr;
    const char *keywords[] = {"target", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlLocation_Type, &target2)) {
        return NULL;
    }
    target_ptr = (target2 ? target2->obj : NULL);
    smlLocationCopy(self->obj, target_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlLocationIsRelative(PySmlLocation *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlLocationIsRelative(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

static PyMethodDef PySmlLocation_methods[] = {
    {(char *) "Compare", (PyCFunction) _wrap_syncmlsmlLocationCompare, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetURI", (PyCFunction) _wrap_syncmlsmlLocationGetURI, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetName", (PyCFunction) _wrap_syncmlsmlLocationSetName, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetName", (PyCFunction) _wrap_syncmlsmlLocationGetName, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Unref", (PyCFunction) _wrap_syncmlsmlLocationUnref, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Copy", (PyCFunction) _wrap_syncmlsmlLocationCopy, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsRelative", (PyCFunction) _wrap_syncmlsmlLocationIsRelative, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlLocation__tp_dealloc(PySmlLocation *self)
{
    if (self->obj) {
    SmlLocation *tmp = self->obj;
    self->obj = NULL;
    smlLocationUnref(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlLocation__tp_richcompare (PySmlLocation *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlLocation_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlLocation",            /* tp_name */
    sizeof(PySmlLocation),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlLocation__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlLocation__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlLocation_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlLocation__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlDevInfProperty__tp_init(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    SmlError *error2 = NULL;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return -1;
    }
    self->obj = smlDevInfNewProperty(&error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}


PyObject *
_wrap_syncmlsmlDevInfPropertyGetNthValEnum(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    char *retval;
    unsigned int n2;
    const char *keywords[] = {"n", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n2)) {
        return NULL;
    }
    retval = smlDevInfPropertyGetNthValEnum(self->obj, n2);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropertyAddValEnum(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *valEnum2;
    const char *keywords[] = {"valEnum", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &valEnum2)) {
        return NULL;
    }
    smlDevInfPropertyAddValEnum(self->obj, valEnum2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropertyGetMaxSize(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfPropertyGetMaxSize(self->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropertySetDisplayName(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *displayName2;
    const char *keywords[] = {"displayName", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &displayName2)) {
        return NULL;
    }
    smlDevInfPropertySetDisplayName(self->obj, displayName2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropertyAddPropParam(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlDevInfPropParam *propParam2;
    SmlDevInfPropParam *propParam_ptr;
    const char *keywords[] = {"propParam", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlDevInfPropParam_Type, &propParam2)) {
        return NULL;
    }
    propParam_ptr = (propParam2 ? propParam2->obj : NULL);
    smlDevInfPropertyAddPropParam(self->obj, propParam_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropertySetDataType(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *dataType2;
    const char *keywords[] = {"dataType", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &dataType2)) {
        return NULL;
    }
    smlDevInfPropertySetDataType(self->obj, dataType2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropertyNumValEnums(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfPropertyNumValEnums(self->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropertyGetDisplayName(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfPropertyGetDisplayName(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropertyNumPropParams(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfPropertyNumPropParams(self->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropertyGetDataType(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfPropertyGetDataType(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropertySetPropName(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *propName2;
    const char *keywords[] = {"propName", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &propName2)) {
        return NULL;
    }
    smlDevInfPropertySetPropName(self->obj, propName2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropertySetPropSize(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int propSize2;
    const char *keywords[] = {"propSize", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &propSize2)) {
        return NULL;
    }
    smlDevInfPropertySetPropSize(self->obj, propSize2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropertyGetMaxOccur(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfPropertyGetMaxOccur(self->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropertyGetPropName(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfPropertyGetPropName(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropertySetNoTruncate(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlDevInfPropertySetNoTruncate(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_syncmlsmlDevInfPropertySetMaxOccur(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int maxOccur2;
    const char *keywords[] = {"maxOccur", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &maxOccur2)) {
        return NULL;
    }
    smlDevInfPropertySetMaxOccur(self->obj, maxOccur2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropertyGetNoTruncate(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlDevInfPropertyGetNoTruncate(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlDevInfPropertySetMaxSize(PySmlDevInfProperty *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int maxSize2;
    const char *keywords[] = {"maxSize", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &maxSize2)) {
        return NULL;
    }
    smlDevInfPropertySetMaxSize(self->obj, maxSize2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PySmlDevInfProperty_methods[] = {
    {(char *) "GetNthValEnum", (PyCFunction) _wrap_syncmlsmlDevInfPropertyGetNthValEnum, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddValEnum", (PyCFunction) _wrap_syncmlsmlDevInfPropertyAddValEnum, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMaxSize", (PyCFunction) _wrap_syncmlsmlDevInfPropertyGetMaxSize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDisplayName", (PyCFunction) _wrap_syncmlsmlDevInfPropertySetDisplayName, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddPropParam", (PyCFunction) _wrap_syncmlsmlDevInfPropertyAddPropParam, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDataType", (PyCFunction) _wrap_syncmlsmlDevInfPropertySetDataType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NumValEnums", (PyCFunction) _wrap_syncmlsmlDevInfPropertyNumValEnums, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDisplayName", (PyCFunction) _wrap_syncmlsmlDevInfPropertyGetDisplayName, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NumPropParams", (PyCFunction) _wrap_syncmlsmlDevInfPropertyNumPropParams, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDataType", (PyCFunction) _wrap_syncmlsmlDevInfPropertyGetDataType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetPropName", (PyCFunction) _wrap_syncmlsmlDevInfPropertySetPropName, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetPropSize", (PyCFunction) _wrap_syncmlsmlDevInfPropertySetPropSize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMaxOccur", (PyCFunction) _wrap_syncmlsmlDevInfPropertyGetMaxOccur, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetPropName", (PyCFunction) _wrap_syncmlsmlDevInfPropertyGetPropName, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetNoTruncate", (PyCFunction) _wrap_syncmlsmlDevInfPropertySetNoTruncate, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetMaxOccur", (PyCFunction) _wrap_syncmlsmlDevInfPropertySetMaxOccur, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNoTruncate", (PyCFunction) _wrap_syncmlsmlDevInfPropertyGetNoTruncate, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetMaxSize", (PyCFunction) _wrap_syncmlsmlDevInfPropertySetMaxSize, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlDevInfProperty__tp_dealloc(PySmlDevInfProperty *self)
{
    if (self->obj) {
    SmlDevInfProperty *tmp = self->obj;
    self->obj = NULL;
    HACKFree(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlDevInfProperty__tp_richcompare (PySmlDevInfProperty *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlDevInfProperty_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlDevInfProperty",            /* tp_name */
    sizeof(PySmlDevInfProperty),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlDevInfProperty__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlDevInfProperty__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlDevInfProperty_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlDevInfProperty__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlTransport__tp_init(PySmlTransport *self, PyObject *args, PyObject *kwargs)
{
    SmlTransportType type2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"type", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &type2)) {
        return -1;
    }
    self->obj = smlTransportNew(type2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}


PyObject *
_wrap_syncmlsmlTransportDisconnect(PySmlTransport *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlLink *link2;
    SmlLink *link_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"link", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlLink_Type, &link2)) {
        return NULL;
    }
    link_ptr = (link2 ? link2->obj : NULL);
    retval = smlTransportDisconnect(self->obj, link_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlTransportFinalize(PySmlTransport *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    SmlError *error2 = NULL;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlTransportFinalize(self->obj, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlTransportGetType(PySmlTransport *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlTransportType retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlTransportGetType(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlTransportStop(PySmlTransport *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlTransportStop(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlTransportFree(PySmlTransport *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlTransportFree(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlTransportRunAsync(PySmlTransport *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    SmlError *error2 = NULL;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlTransportRunAsync(self->obj, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlTransportSetConnectionType(PySmlTransport *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    SmlTransportConnectionType type2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"type", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &type2)) {
        return NULL;
    }
    retval = smlTransportSetConnectionType(self->obj, type2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlTransportConnect(PySmlTransport *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    SmlError *error2 = NULL;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlTransportConnect(self->obj, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlTransportSend(PySmlTransport *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlLink *link2;
    SmlLink *link_ptr;
    PySmlTransportData *data2;
    SmlTransportData *data_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"link", "data", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "OO!", (char **) keywords, &link2, &PySmlTransportData_Type, &data2)) {
        return NULL;
    }
    if (link2 && ((PyObject *) link2 != Py_None) && !PyObject_IsInstance((PyObject *) link2, (PyObject *) &PySmlLink_Type)) {
        PyErr_SetString(PyExc_TypeError, "Parameter 1 must be SmlLink");
        return NULL;
    }
    if (link2) {
        if ((PyObject *) link2 == Py_None)
            link_ptr = NULL;
        else
            link_ptr = link2->obj;
    } else {
        link_ptr = NULL;
    }
    data_ptr = (data2 ? data2->obj : NULL);
    retval = smlTransportSend(self->obj, link_ptr, data_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlTransportInitialize(PySmlTransport *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    SmlError *error2 = NULL;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlTransportInitialize(self->obj, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlTransportSetConfigOption(PySmlTransport *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    const char *name2;
    const char *value2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"name", "value", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ss", (char **) keywords, &name2, &value2)) {
        return NULL;
    }
    retval = smlTransportSetConfigOption(self->obj, name2, value2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlTransportSetError(PySmlTransport *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlLink *link2;
    SmlLink *link_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"link", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlLink_Type, &link2)) {
        return NULL;
    }
    link_ptr = (link2 ? link2->obj : NULL);
    smlTransportSetError(self->obj, link_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PySmlTransport_methods[] = {
    {(char *) "Disconnect", (PyCFunction) _wrap_syncmlsmlTransportDisconnect, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Finalize", (PyCFunction) _wrap_syncmlsmlTransportFinalize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetType", (PyCFunction) _wrap_syncmlsmlTransportGetType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Stop", (PyCFunction) _wrap_syncmlsmlTransportStop, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Free", (PyCFunction) _wrap_syncmlsmlTransportFree, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RunAsync", (PyCFunction) _wrap_syncmlsmlTransportRunAsync, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetConnectionType", (PyCFunction) _wrap_syncmlsmlTransportSetConnectionType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Connect", (PyCFunction) _wrap_syncmlsmlTransportConnect, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Send", (PyCFunction) _wrap_syncmlsmlTransportSend, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Initialize", (PyCFunction) _wrap_syncmlsmlTransportInitialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetConfigOption", (PyCFunction) _wrap_syncmlsmlTransportSetConfigOption, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetError", (PyCFunction) _wrap_syncmlsmlTransportSetError, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlTransport__tp_dealloc(PySmlTransport *self)
{
    if (self->obj) {
    SmlTransport *tmp = self->obj;
    self->obj = NULL;
    smlTransportFree(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlTransport__tp_richcompare (PySmlTransport *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlTransport_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlTransport",            /* tp_name */
    sizeof(PySmlTransport),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlTransport__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlTransport__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlTransport_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlTransport__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlItem__tp_init(PySmlItem *self, PyObject *args, PyObject *kwargs)
{
    unsigned int size2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"size", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &size2)) {
        return -1;
    }
    self->obj = smlItemNew(size2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}


PyObject *
_wrap_syncmlsmlItemSetTarget(PySmlItem *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlLocation *target2;
    SmlLocation *target_ptr;
    const char *keywords[] = {"target", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlLocation_Type, &target2)) {
        return NULL;
    }
    target_ptr = (target2 ? target2->obj : NULL);
    smlItemSetTarget(self->obj, target_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlItemAddData(PySmlItem *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    const char *data2;
    unsigned int size2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"data", "size", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "sI", (char **) keywords, &data2, &size2)) {
        return NULL;
    }
    retval = smlItemAddData(self->obj, data2, size2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlItemUnref(PySmlItem *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlItemUnref(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlItemSetRaw(PySmlItem *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool raw2;
    const char *keywords[] = {"raw", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &raw2)) {
        return NULL;
    }
    smlItemSetRaw(self->obj, raw2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlItemHasData(PySmlItem *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlItemHasData(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlItemCheck(PySmlItem *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlItemCheck(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlItemSetSource(PySmlItem *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlLocation *source2;
    SmlLocation *source_ptr;
    const char *keywords[] = {"source", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlLocation_Type, &source2)) {
        return NULL;
    }
    source_ptr = (source2 ? source2->obj : NULL);
    smlItemSetSource(self->obj, source_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PySmlItem_methods[] = {
    {(char *) "SetTarget", (PyCFunction) _wrap_syncmlsmlItemSetTarget, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddData", (PyCFunction) _wrap_syncmlsmlItemAddData, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Unref", (PyCFunction) _wrap_syncmlsmlItemUnref, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetRaw", (PyCFunction) _wrap_syncmlsmlItemSetRaw, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "HasData", (PyCFunction) _wrap_syncmlsmlItemHasData, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Check", (PyCFunction) _wrap_syncmlsmlItemCheck, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetSource", (PyCFunction) _wrap_syncmlsmlItemSetSource, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlItem__tp_dealloc(PySmlItem *self)
{
    if (self->obj) {
    SmlItem *tmp = self->obj;
    self->obj = NULL;
    smlItemUnref(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlItem__tp_richcompare (PySmlItem *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlItem_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlItem",            /* tp_name */
    sizeof(PySmlItem),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlItem__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlItem__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlItem_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlItem__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlCommand__tp_init(PySmlCommand *self, PyObject *args, PyObject *kwargs)
{
    SmlCommandType type2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"type", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &type2)) {
        return -1;
    }
    self->obj = smlCommandNew(type2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}


PyObject *
_wrap_syncmlsmlCommandUnref(PySmlCommand *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlCommandUnref(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlCommandAddMapItem(PySmlCommand *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlMapItem *item2;
    SmlMapItem *item_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"item", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlMapItem_Type, &item2)) {
        return NULL;
    }
    item_ptr = (item2 ? item2->obj : NULL);
    retval = smlCommandAddMapItem(self->obj, item_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

static PyMethodDef PySmlCommand_methods[] = {
    {(char *) "Unref", (PyCFunction) _wrap_syncmlsmlCommandUnref, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddMapItem", (PyCFunction) _wrap_syncmlsmlCommandAddMapItem, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlCommand__tp_dealloc(PySmlCommand *self)
{
    if (self->obj) {
    SmlCommand *tmp = self->obj;
    self->obj = NULL;
    smlCommandUnref(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlCommand__tp_richcompare (PySmlCommand *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlCommand_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlCommand",            /* tp_name */
    sizeof(PySmlCommand),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlCommand__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlCommand__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlCommand_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlCommand__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlCred__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'SmlCred' cannot be constructed ()");
    return -1;
}


PyObject *
_wrap_syncmlsmlCredUnref(PySmlCred *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlCredUnref(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlCredRef(PySmlCred *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlCredRef(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlCredFree(PySmlCred *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlCredFree(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PySmlCred_methods[] = {
    {(char *) "Unref", (PyCFunction) _wrap_syncmlsmlCredUnref, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Ref", (PyCFunction) _wrap_syncmlsmlCredRef, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Free", (PyCFunction) _wrap_syncmlsmlCredFree, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlCred__tp_dealloc(PySmlCred *self)
{
    
    if (self->obj) {
    SmlCred *tmp = self->obj;
    self->obj = NULL;
    smlCredUnref(tmp);
}
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlCred__tp_richcompare (PySmlCred *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlCred_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlCred",            /* tp_name */
    sizeof(PySmlCred),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlCred__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlCred__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlCred_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlCred__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlLink__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'SmlLink' cannot be constructed ()");
    return -1;
}


PyObject *
_wrap_syncmlsmlLinkDeref(PySmlLink *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlLinkDeref(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PySmlLink_methods[] = {
    {(char *) "Deref", (PyCFunction) _wrap_syncmlsmlLinkDeref, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlLink__tp_dealloc(PySmlLink *self)
{
    
    if (self->obj) {
    SmlLink *tmp = self->obj;
    self->obj = NULL;
    smlLinkDeref(tmp);
}
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlLink__tp_richcompare (PySmlLink *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlLink_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlLink",            /* tp_name */
    sizeof(PySmlLink),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlLink__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlLink__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlLink_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlLink__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlSession__tp_init(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    SmlSessionType sessionType2;
    SmlMimeType mimetype2;
    SmlProtocolVersion version2;
    SmlProtocolType protocol2;
    PySmlLocation *target2;
    SmlLocation *target_ptr;
    PySmlLocation *source2;
    SmlLocation *source_ptr;
    const char *sessionID2;
    unsigned int messageID2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"sessionType", "mimetype", "version", "protocol", "target", "source", "sessionID", "messageID", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iiiiO!O!sI", (char **) keywords, &sessionType2, &mimetype2, &version2, &protocol2, &PySmlLocation_Type, &target2, &PySmlLocation_Type, &source2, &sessionID2, &messageID2)) {
        return -1;
    }
    target_ptr = (target2 ? target2->obj : NULL);
    source_ptr = (source2 ? source2->obj : NULL);
    self->obj = smlSessionNew(sessionType2, mimetype2, version2, protocol2, target_ptr, source_ptr, sessionID2, messageID2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}


PyObject *
_wrap_syncmlsmlSessionSetRequestedMaxObjSize(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int limit2;
    const char *keywords[] = {"limit", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &limit2)) {
        return NULL;
    }
    smlSessionSetRequestedMaxObjSize(self->obj, limit2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionGetSendingMaxMsgSize(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlSessionGetSendingMaxMsgSize(self->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionRegisterCred(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySmlCred *cred2;
    SmlCred *cred_ptr;
    const char *keywords[] = {"cred", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlCred_Type, &cred2)) {
        return NULL;
    }
    cred_ptr = (cred2 ? cred2->obj : NULL);
    smlSessionRegisterCred(self->obj, cred_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionUseLargeObjects(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool support2;
    const char *keywords[] = {"support", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &support2)) {
        return NULL;
    }
    smlSessionUseLargeObjects(self->obj, support2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionEnd(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    SmlError *error2 = NULL;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlSessionEnd(self->obj, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionEndCommand(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlCommand *parent2;
    SmlCommand *parent_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"parent", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlCommand_Type, &parent2)) {
        return NULL;
    }
    parent_ptr = (parent2 ? parent2->obj : NULL);
    retval = smlSessionEndCommand(self->obj, parent_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionUseOnlyReplace(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool onlyReplace2;
    const char *keywords[] = {"onlyReplace", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &onlyReplace2)) {
        return NULL;
    }
    smlSessionUseOnlyReplace(self->obj, onlyReplace2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionSetSendingMaxMsgSize(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int size2;
    const char *keywords[] = {"size", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &size2)) {
        return NULL;
    }
    smlSessionSetSendingMaxMsgSize(self->obj, size2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionSendReply(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlStatus *status2;
    SmlStatus *status_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"status", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlStatus_Type, &status2)) {
        return NULL;
    }
    status_ptr = (status2 ? status2->obj : NULL);
    retval = smlSessionSendReply(self->obj, status_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionGetSessionID(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlSessionGetSessionID(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionSetSendingMaxObjSize(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int limit2;
    const char *keywords[] = {"limit", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &limit2)) {
        return NULL;
    }
    smlSessionSetSendingMaxObjSize(self->obj, limit2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionSetReceivingMaxMsgSize(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int size2;
    const char *keywords[] = {"size", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &size2)) {
        return NULL;
    }
    smlSessionSetReceivingMaxMsgSize(self->obj, size2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionUseStringTable(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool useStringtable2;
    const char *keywords[] = {"useStringtable", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &useStringtable2)) {
        return NULL;
    }
    smlSessionUseStringTable(self->obj, useStringtable2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionSetReceivingMaxObjSize(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int limit2;
    const char *keywords[] = {"limit", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &limit2)) {
        return NULL;
    }
    smlSessionSetReceivingMaxObjSize(self->obj, limit2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionUnref(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlSessionUnref(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionSetSessionID(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *sessionID2;
    const char *keywords[] = {"sessionID", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &sessionID2)) {
        return NULL;
    }
    smlSessionSetSessionID(self->obj, sessionID2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionGetSendingMaxObjSize(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlSessionGetSendingMaxObjSize(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionUseNumberOfChanges(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool support2;
    const char *keywords[] = {"support", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &support2)) {
        return NULL;
    }
    smlSessionUseNumberOfChanges(self->obj, support2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionDispatch(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlSessionDispatch(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionReceiveHeader(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    PySmlHeader *header2;
    SmlHeader *header_ptr;
    SmlError *error2 = NULL;
    const char *keywords[] = {"header", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySmlHeader_Type, &header2)) {
        return NULL;
    }
    header_ptr = (header2 ? header2->obj : NULL);
    retval = smlSessionReceiveHeader(self->obj, header_ptr, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionFlush(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    SmlBool final2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"final", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &final2)) {
        return NULL;
    }
    retval = smlSessionFlush(self->obj, final2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionGetVersion(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlProtocolVersion retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlSessionGetVersion(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionCheck(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlSessionCheck(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSessionGetReceivingMaxObjSize(PySmlSession *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlSessionGetReceivingMaxObjSize(self->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}

static PyMethodDef PySmlSession_methods[] = {
    {(char *) "SetRequestedMaxObjSize", (PyCFunction) _wrap_syncmlsmlSessionSetRequestedMaxObjSize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetSendingMaxMsgSize", (PyCFunction) _wrap_syncmlsmlSessionGetSendingMaxMsgSize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RegisterCred", (PyCFunction) _wrap_syncmlsmlSessionRegisterCred, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "UseLargeObjects", (PyCFunction) _wrap_syncmlsmlSessionUseLargeObjects, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "End", (PyCFunction) _wrap_syncmlsmlSessionEnd, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EndCommand", (PyCFunction) _wrap_syncmlsmlSessionEndCommand, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "UseOnlyReplace", (PyCFunction) _wrap_syncmlsmlSessionUseOnlyReplace, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetSendingMaxMsgSize", (PyCFunction) _wrap_syncmlsmlSessionSetSendingMaxMsgSize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SendReply", (PyCFunction) _wrap_syncmlsmlSessionSendReply, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetSessionID", (PyCFunction) _wrap_syncmlsmlSessionGetSessionID, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetSendingMaxObjSize", (PyCFunction) _wrap_syncmlsmlSessionSetSendingMaxObjSize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetReceivingMaxMsgSize", (PyCFunction) _wrap_syncmlsmlSessionSetReceivingMaxMsgSize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "UseStringTable", (PyCFunction) _wrap_syncmlsmlSessionUseStringTable, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetReceivingMaxObjSize", (PyCFunction) _wrap_syncmlsmlSessionSetReceivingMaxObjSize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Unref", (PyCFunction) _wrap_syncmlsmlSessionUnref, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetSessionID", (PyCFunction) _wrap_syncmlsmlSessionSetSessionID, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetSendingMaxObjSize", (PyCFunction) _wrap_syncmlsmlSessionGetSendingMaxObjSize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "UseNumberOfChanges", (PyCFunction) _wrap_syncmlsmlSessionUseNumberOfChanges, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Dispatch", (PyCFunction) _wrap_syncmlsmlSessionDispatch, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "ReceiveHeader", (PyCFunction) _wrap_syncmlsmlSessionReceiveHeader, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Flush", (PyCFunction) _wrap_syncmlsmlSessionFlush, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetVersion", (PyCFunction) _wrap_syncmlsmlSessionGetVersion, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Check", (PyCFunction) _wrap_syncmlsmlSessionCheck, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetReceivingMaxObjSize", (PyCFunction) _wrap_syncmlsmlSessionGetReceivingMaxObjSize, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlSession__tp_dealloc(PySmlSession *self)
{
    if (self->obj) {
    SmlSession *tmp = self->obj;
    self->obj = NULL;
    smlSessionUnref(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlSession__tp_richcompare (PySmlSession *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlSession_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlSession",            /* tp_name */
    sizeof(PySmlSession),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlSession__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlSession__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlSession_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlSession__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlObject__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'SmlObject' cannot be constructed ()");
    return -1;
}

static PyMethodDef PySmlObject_methods[] = {
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlObject__tp_dealloc(PySmlObject *self)
{
    
    if (self->obj) {
    SmlObject *tmp = self->obj;
    self->obj = NULL;
    smlManagerObjectFree(tmp);
}
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlObject__tp_richcompare (PySmlObject *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlObject_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlObject",            /* tp_name */
    sizeof(PySmlObject),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlObject__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlObject__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlObject_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlObject__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlAuthenticator__tp_init(PySmlAuthenticator *self, PyObject *args, PyObject *kwargs)
{
    SmlError *error2 = NULL;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return -1;
    }
    self->obj = smlAuthNew(&error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}

static PyMethodDef PySmlAuthenticator_methods[] = {
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlAuthenticator__tp_dealloc(PySmlAuthenticator *self)
{
    if (self->obj) {
    SmlAuthenticator *tmp = self->obj;
    self->obj = NULL;
    smlAuthFree(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlAuthenticator__tp_richcompare (PySmlAuthenticator *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlAuthenticator_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlAuthenticator",            /* tp_name */
    sizeof(PySmlAuthenticator),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlAuthenticator__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlAuthenticator__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlAuthenticator_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlAuthenticator__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlStatus__tp_init(PySmlStatus *self, PyObject *args, PyObject *kwargs)
{
    SmlErrorType data2;
    unsigned int cmdref2;
    unsigned int msgref2;
    PySmlLocation *sourceref2;
    SmlLocation *sourceref_ptr;
    PySmlLocation *targeref2;
    SmlLocation *targeref_ptr;
    SmlCommandType type2;
    SmlError *error2 = NULL;
    const char *keywords[] = {"data", "cmdref", "msgref", "sourceref", "targeref", "type", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iIIO!O!i", (char **) keywords, &data2, &cmdref2, &msgref2, &PySmlLocation_Type, &sourceref2, &PySmlLocation_Type, &targeref2, &type2)) {
        return -1;
    }
    sourceref_ptr = (sourceref2 ? sourceref2->obj : NULL);
    targeref_ptr = (targeref2 ? targeref2->obj : NULL);
    self->obj = smlStatusNew(data2, cmdref2, msgref2, sourceref_ptr, targeref_ptr, type2, &error2);
    if (smlErrorIsSet(&error2)) {
        PyErr_SetString(PyExc_RuntimeError, smlErrorPrint(&error2));
        smlErrorDeref(&error2);
        return -1;
    }
    return 0;
}


PyObject *
_wrap_syncmlsmlStatusUnref(PySmlStatus *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    smlStatusUnref(self->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_syncmlsmlStatusIsResult(PySmlStatus *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlBool retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlStatusIsResult(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlStatusGetClass(PySmlStatus *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlErrorClass retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlStatusGetClass(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlStatusGetCode(PySmlStatus *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlErrorType retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlStatusGetCode(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

static PyMethodDef PySmlStatus_methods[] = {
    {(char *) "Unref", (PyCFunction) _wrap_syncmlsmlStatusUnref, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsResult", (PyCFunction) _wrap_syncmlsmlStatusIsResult, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetClass", (PyCFunction) _wrap_syncmlsmlStatusGetClass, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetCode", (PyCFunction) _wrap_syncmlsmlStatusGetCode, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlStatus__tp_dealloc(PySmlStatus *self)
{
    if (self->obj) {
    SmlStatus *tmp = self->obj;
    self->obj = NULL;
    smlStatusUnref(tmp);
}
    
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlStatus__tp_richcompare (PySmlStatus *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlStatus_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlStatus",            /* tp_name */
    sizeof(PySmlStatus),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlStatus__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlStatus__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlStatus_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlStatus__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PySmlSanAlert__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'SmlSanAlert' cannot be constructed ()");
    return -1;
}


PyObject *
_wrap_syncmlsmlSanAlertGetServerURI(PySmlSanAlert *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlSanAlertGetServerURI(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSanAlertGetType(PySmlSanAlert *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SmlAlertType retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlSanAlertGetType(self->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_syncmlsmlSanAlertGetContentType(PySmlSanAlert *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return NULL;
    }
    retval = smlSanAlertGetContentType(self->obj);
    py_retval = Py_BuildValue((char *) "s", retval);
    return py_retval;
}

static PyMethodDef PySmlSanAlert_methods[] = {
    {(char *) "GetServerURI", (PyCFunction) _wrap_syncmlsmlSanAlertGetServerURI, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetType", (PyCFunction) _wrap_syncmlsmlSanAlertGetType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetContentType", (PyCFunction) _wrap_syncmlsmlSanAlertGetContentType, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySmlSanAlert__tp_dealloc(PySmlSanAlert *self)
{
    
    if (self->obj) {
    SmlSanAlert *tmp = self->obj;
    self->obj = NULL;
    smlNotificationFreeAlert(tmp);
}
    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_PySmlSanAlert__tp_richcompare (PySmlSanAlert *self, PyObject *o2, int opid)
{
    PyErr_SetString(PyExc_TypeError, "Comparison not defined or not yet implemented.");
    return NULL;
}

PyTypeObject PySmlSanAlert_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "syncml.SmlSanAlert",            /* tp_name */
    sizeof(PySmlSanAlert),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySmlSanAlert__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySmlSanAlert__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySmlSanAlert_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySmlSanAlert__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};


/* --- enumerations --- */






















































PyMODINIT_FUNC
initsyncml(void)
{
    PyObject *m;
    PyObject *submodule;
    m = Py_InitModule3((char *) "syncml", syncml_functions, NULL);
    if (m == NULL) {
        return;
    }
    /* Register the 'SmlTransportData' class */
    if (PyType_Ready(&PySmlTransportData_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "TransportData", (PyObject *) &PySmlTransportData_Type);
    /* Register the 'SmlDevInfAgent' class */
    if (PyType_Ready(&PySmlDevInfAgent_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "DevInfAgent", (PyObject *) &PySmlDevInfAgent_Type);
    /* Register the 'SmlAnchor' class */
    if (PyType_Ready(&PySmlAnchor_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Anchor", (PyObject *) &PySmlAnchor_Type);
    /* Register the 'SmlDevInfDataStore' class */
    if (PyType_Ready(&PySmlDevInfDataStore_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "DevInfDataStore", (PyObject *) &PySmlDevInfDataStore_Type);
    /* Register the 'SmlDevInfPropParam' class */
    if (PyType_Ready(&PySmlDevInfPropParam_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "DevInfPropParam", (PyObject *) &PySmlDevInfPropParam_Type);
    /* Register the 'SmlDevInfContentType' class */
    if (PyType_Ready(&PySmlDevInfContentType_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "DevInfContentType", (PyObject *) &PySmlDevInfContentType_Type);
    /* Register the 'SmlDevInfCTCap' class */
    if (PyType_Ready(&PySmlDevInfCTCap_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "DevInfCTCap", (PyObject *) &PySmlDevInfCTCap_Type);
    /* Register the 'SmlDevInf' class */
    if (PyType_Ready(&PySmlDevInf_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "DevInf", (PyObject *) &PySmlDevInf_Type);
    /* Register the 'SmlChal' class */
    if (PyType_Ready(&PySmlChal_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Chal", (PyObject *) &PySmlChal_Type);
    /* Register the 'SmlNotification' class */
    if (PyType_Ready(&PySmlNotification_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Notification", (PyObject *) &PySmlNotification_Type);
    /* Register the 'SmlMapItem' class */
    if (PyType_Ready(&PySmlMapItem_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "MapItem", (PyObject *) &PySmlMapItem_Type);
    /* Register the 'SmlHeader' class */
    if (PyType_Ready(&PySmlHeader_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Header", (PyObject *) &PySmlHeader_Type);
    /* Register the 'SmlManager' class */
    if (PyType_Ready(&PySmlManager_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Manager", (PyObject *) &PySmlManager_Type);
    /* Register the 'SmlLocation' class */
    if (PyType_Ready(&PySmlLocation_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Location", (PyObject *) &PySmlLocation_Type);
    /* Register the 'SmlDevInfProperty' class */
    if (PyType_Ready(&PySmlDevInfProperty_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "DevInfProperty", (PyObject *) &PySmlDevInfProperty_Type);
    /* Register the 'SmlTransport' class */
    if (PyType_Ready(&PySmlTransport_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Transport", (PyObject *) &PySmlTransport_Type);
    /* Register the 'SmlItem' class */
    if (PyType_Ready(&PySmlItem_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Item", (PyObject *) &PySmlItem_Type);
    /* Register the 'SmlCommand' class */
    if (PyType_Ready(&PySmlCommand_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Command", (PyObject *) &PySmlCommand_Type);
    /* Register the 'SmlCred' class */
    if (PyType_Ready(&PySmlCred_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Cred", (PyObject *) &PySmlCred_Type);
    /* Register the 'SmlLink' class */
    if (PyType_Ready(&PySmlLink_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Link", (PyObject *) &PySmlLink_Type);
    /* Register the 'SmlSession' class */
    if (PyType_Ready(&PySmlSession_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Session", (PyObject *) &PySmlSession_Type);
    /* Register the 'SmlObject' class */
    if (PyType_Ready(&PySmlObject_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Object", (PyObject *) &PySmlObject_Type);
    /* Register the 'SmlAuthenticator' class */
    if (PyType_Ready(&PySmlAuthenticator_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Authenticator", (PyObject *) &PySmlAuthenticator_Type);
    /* Register the 'SmlStatus' class */
    if (PyType_Ready(&PySmlStatus_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Status", (PyObject *) &PySmlStatus_Type);
    /* Register the 'SmlSanAlert' class */
    if (PyType_Ready(&PySmlSanAlert_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SanAlert", (PyObject *) &PySmlSanAlert_Type);
    PyModule_AddIntConstant(m, (char *) "SML_ALERT_UNKNOWN", SML_ALERT_UNKNOWN);
    PyModule_AddIntConstant(m, (char *) "SML_ALERT_DISPLAY", SML_ALERT_DISPLAY);
    PyModule_AddIntConstant(m, (char *) "SML_ALERT_TWO_WAY", SML_ALERT_TWO_WAY);
    PyModule_AddIntConstant(m, (char *) "SML_ALERT_SLOW_SYNC", SML_ALERT_SLOW_SYNC);
    PyModule_AddIntConstant(m, (char *) "SML_ALERT_ONE_WAY_FROM_CLIENT", SML_ALERT_ONE_WAY_FROM_CLIENT);
    PyModule_AddIntConstant(m, (char *) "SML_ALERT_REFRESH_FROM_CLIENT", SML_ALERT_REFRESH_FROM_CLIENT);
    PyModule_AddIntConstant(m, (char *) "SML_ALERT_ONE_WAY_FROM_SERVER", SML_ALERT_ONE_WAY_FROM_SERVER);
    PyModule_AddIntConstant(m, (char *) "SML_ALERT_REFRESH_FROM_SERVER", SML_ALERT_REFRESH_FROM_SERVER);
    PyModule_AddIntConstant(m, (char *) "SML_ALERT_TWO_WAY_BY_SERVER", SML_ALERT_TWO_WAY_BY_SERVER);
    PyModule_AddIntConstant(m, (char *) "SML_ALERT_ONE_WAY_FROM_CLIENT_BY_SERVER", SML_ALERT_ONE_WAY_FROM_CLIENT_BY_SERVER);
    PyModule_AddIntConstant(m, (char *) "SML_ALERT_REFRESH_FROM_CLIENT_BY_SERVER", SML_ALERT_REFRESH_FROM_CLIENT_BY_SERVER);
    PyModule_AddIntConstant(m, (char *) "SML_ALERT_ONE_WAY_FROM_SERVER_BY_SERVER", SML_ALERT_ONE_WAY_FROM_SERVER_BY_SERVER);
    PyModule_AddIntConstant(m, (char *) "SML_ALERT_REFRESH_FROM_SERVER_BY_SERVER", SML_ALERT_REFRESH_FROM_SERVER_BY_SERVER);
    PyModule_AddIntConstant(m, (char *) "SML_ALERT_RESULT", SML_ALERT_RESULT);
    PyModule_AddIntConstant(m, (char *) "SML_ALERT_NEXT_MESSAGE", SML_ALERT_NEXT_MESSAGE);
    PyModule_AddIntConstant(m, (char *) "SML_ALERT_NO_END_OF_DATA", SML_ALERT_NO_END_OF_DATA);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_SYNCTYPE_UNKNOWN", SML_DEVINF_SYNCTYPE_UNKNOWN);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_SYNCTYPE_TWO_WAY", SML_DEVINF_SYNCTYPE_TWO_WAY);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_SYNCTYPE_SLOW_SYNC", SML_DEVINF_SYNCTYPE_SLOW_SYNC);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_SYNCTYPE_ONE_WAY_FROM_CLIENT", SML_DEVINF_SYNCTYPE_ONE_WAY_FROM_CLIENT);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_SYNCTYPE_REFRESH_FROM_CLIENT", SML_DEVINF_SYNCTYPE_REFRESH_FROM_CLIENT);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_SYNCTYPE_ONE_WAY_FROM_SERVER", SML_DEVINF_SYNCTYPE_ONE_WAY_FROM_SERVER);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_SYNCTYPE_REFRESH_FROM_SERVER", SML_DEVINF_SYNCTYPE_REFRESH_FROM_SERVER);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_SYNCTYPE_SERVER_ALERTED_SYNC", SML_DEVINF_SYNCTYPE_SERVER_ALERTED_SYNC);
    PyModule_AddIntConstant(m, (char *) "SML_TRANSPORT_EVENT_CONNECT_DONE", SML_TRANSPORT_EVENT_CONNECT_DONE);
    PyModule_AddIntConstant(m, (char *) "SML_TRANSPORT_EVENT_DISCONNECT_DONE", SML_TRANSPORT_EVENT_DISCONNECT_DONE);
    PyModule_AddIntConstant(m, (char *) "SML_TRANSPORT_EVENT_ERROR", SML_TRANSPORT_EVENT_ERROR);
    PyModule_AddIntConstant(m, (char *) "SML_TRANSPORT_EVENT_DATA", SML_TRANSPORT_EVENT_DATA);
    PyModule_AddIntConstant(m, (char *) "SML_ERRORCLASS_UNKNOWN", SML_ERRORCLASS_UNKNOWN);
    PyModule_AddIntConstant(m, (char *) "SML_ERRORCLASS_SUCCESS", SML_ERRORCLASS_SUCCESS);
    PyModule_AddIntConstant(m, (char *) "SML_ERRORCLASS_RETRY", SML_ERRORCLASS_RETRY);
    PyModule_AddIntConstant(m, (char *) "SML_ERRORCLASS_FATAL", SML_ERRORCLASS_FATAL);
    PyModule_AddIntConstant(m, (char *) "SML_MIMETYPE_UNKNOWN", SML_MIMETYPE_UNKNOWN);
    PyModule_AddIntConstant(m, (char *) "SML_MIMETYPE_XML", SML_MIMETYPE_XML);
    PyModule_AddIntConstant(m, (char *) "SML_MIMETYPE_WBXML", SML_MIMETYPE_WBXML);
    PyModule_AddIntConstant(m, (char *) "SML_MIMETYPE_SAN", SML_MIMETYPE_SAN);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_UNKNOWN", SML_ERROR_UNKNOWN);
    PyModule_AddIntConstant(m, (char *) "SML_IN_PROGRESS", SML_IN_PROGRESS);
    PyModule_AddIntConstant(m, (char *) "SML_NO_ERROR", SML_NO_ERROR);
    PyModule_AddIntConstant(m, (char *) "SML_ITEM_ADDED", SML_ITEM_ADDED);
    PyModule_AddIntConstant(m, (char *) "SML_PROCESSING_ACCEPTED", SML_PROCESSING_ACCEPTED);
    PyModule_AddIntConstant(m, (char *) "SML_NON_AUTHORITATIVE", SML_NON_AUTHORITATIVE);
    PyModule_AddIntConstant(m, (char *) "SML_NO_CONTENT", SML_NO_CONTENT);
    PyModule_AddIntConstant(m, (char *) "SML_RESET_CONTENT", SML_RESET_CONTENT);
    PyModule_AddIntConstant(m, (char *) "SML_PARTIAL_CONTENT", SML_PARTIAL_CONTENT);
    PyModule_AddIntConstant(m, (char *) "SML_CONFLICT_MERGE", SML_CONFLICT_MERGE);
    PyModule_AddIntConstant(m, (char *) "SML_CONFLICT_CLIENT_WIN", SML_CONFLICT_CLIENT_WIN);
    PyModule_AddIntConstant(m, (char *) "SML_CONFLICT_DUPLICATE", SML_CONFLICT_DUPLICATE);
    PyModule_AddIntConstant(m, (char *) "SML_DELETE_NO_ARCHIVE", SML_DELETE_NO_ARCHIVE);
    PyModule_AddIntConstant(m, (char *) "SML_DELETE_NOT_FOUND", SML_DELETE_NOT_FOUND);
    PyModule_AddIntConstant(m, (char *) "SML_AUTH_ACCEPTED", SML_AUTH_ACCEPTED);
    PyModule_AddIntConstant(m, (char *) "SML_CHUNK_ACCEPTED", SML_CHUNK_ACCEPTED);
    PyModule_AddIntConstant(m, (char *) "SML_OPERATION_CANCELLED", SML_OPERATION_CANCELLED);
    PyModule_AddIntConstant(m, (char *) "SML_NOT_EXECUTED", SML_NOT_EXECUTED);
    PyModule_AddIntConstant(m, (char *) "SML_ATOMIC_ROLLBACK_OK", SML_ATOMIC_ROLLBACK_OK);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_RETRY", SML_ERROR_RETRY);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_TIMEOUT_RETRY", SML_ERROR_TIMEOUT_RETRY);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_FOUND_RETRY", SML_ERROR_FOUND_RETRY);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_SEE_OTHER_RETRY", SML_ERROR_SEE_OTHER_RETRY);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_NOT_MODIFIED", SML_ERROR_NOT_MODIFIED);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_USE_PROXY", SML_ERROR_USE_PROXY);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_BAD_REQUEST", SML_ERROR_BAD_REQUEST);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_AUTH_REJECTED", SML_ERROR_AUTH_REJECTED);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_PAYMENT_NEEDED", SML_ERROR_PAYMENT_NEEDED);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_FORBIDDEN", SML_ERROR_FORBIDDEN);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_NOT_FOUND", SML_ERROR_NOT_FOUND);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_COMMAND_NOT_ALLOWED", SML_ERROR_COMMAND_NOT_ALLOWED);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_UNSUPPORTED_FEATURE", SML_ERROR_UNSUPPORTED_FEATURE);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_AUTH_REQUIRED", SML_ERROR_AUTH_REQUIRED);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_ALREADY_EXISTS", SML_ERROR_ALREADY_EXISTS);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_SIZE_MISMATCH", SML_ERROR_SIZE_MISMATCH);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_GENERIC", SML_ERROR_GENERIC);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_IO_ERROR", SML_ERROR_IO_ERROR);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_NOT_SUPPORTED", SML_ERROR_NOT_SUPPORTED);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_TIMEOUT", SML_ERROR_TIMEOUT);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_DISCONNECTED", SML_ERROR_DISCONNECTED);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_FILE_NOT_FOUND", SML_ERROR_FILE_NOT_FOUND);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_MISCONFIGURATION", SML_ERROR_MISCONFIGURATION);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_INITIALIZATION", SML_ERROR_INITIALIZATION);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_REQUIRE_REFRESH", SML_ERROR_REQUIRE_REFRESH);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_EXPECTED", SML_ERROR_EXPECTED);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_NO_CONNECTION", SML_ERROR_NO_CONNECTION);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_TEMPORARY", SML_ERROR_TEMPORARY);
    PyModule_AddIntConstant(m, (char *) "SML_ERROR_NO_MEMORY", SML_ERROR_NO_MEMORY);
    PyModule_AddIntConstant(m, (char *) "SML_TRANSPORT_HTTP_SERVER", SML_TRANSPORT_HTTP_SERVER);
    PyModule_AddIntConstant(m, (char *) "SML_TRANSPORT_HTTP_CLIENT", SML_TRANSPORT_HTTP_CLIENT);
    PyModule_AddIntConstant(m, (char *) "SML_TRANSPORT_OBEX_CLIENT", SML_TRANSPORT_OBEX_CLIENT);
    PyModule_AddIntConstant(m, (char *) "SML_TRANSPORT_OBEX_SERVER", SML_TRANSPORT_OBEX_SERVER);
    PyModule_AddIntConstant(m, (char *) "SML_RESULT_OK", SML_RESULT_OK);
    PyModule_AddIntConstant(m, (char *) "SML_RESULT_RETRY", SML_RESULT_RETRY);
    PyModule_AddIntConstant(m, (char *) "SML_RESULT_FATAL", SML_RESULT_FATAL);
    PyModule_AddIntConstant(m, (char *) "SML_SESSION_EVENT_ERROR", SML_SESSION_EVENT_ERROR);
    PyModule_AddIntConstant(m, (char *) "SML_SESSION_EVENT_COMMAND_START", SML_SESSION_EVENT_COMMAND_START);
    PyModule_AddIntConstant(m, (char *) "SML_SESSION_EVENT_CHILD_COMMAND", SML_SESSION_EVENT_CHILD_COMMAND);
    PyModule_AddIntConstant(m, (char *) "SML_SESSION_EVENT_HEADER_REPLY", SML_SESSION_EVENT_HEADER_REPLY);
    PyModule_AddIntConstant(m, (char *) "SML_SESSION_EVENT_FINAL", SML_SESSION_EVENT_FINAL);
    PyModule_AddIntConstant(m, (char *) "SML_SESSION_EVENT_END", SML_SESSION_EVENT_END);
    PyModule_AddIntConstant(m, (char *) "SML_SESSION_EVENT_FLUSH", SML_SESSION_EVENT_FLUSH);
    PyModule_AddIntConstant(m, (char *) "SML_SESSION_EVENT_COMMAND_END", SML_SESSION_EVENT_COMMAND_END);
    PyModule_AddIntConstant(m, (char *) "SML_SESSION_EVENT_RESPONSE_URI", SML_SESSION_EVENT_RESPONSE_URI);
    PyModule_AddIntConstant(m, (char *) "SML_MANAGER_CONNECT_DONE", SML_MANAGER_CONNECT_DONE);
    PyModule_AddIntConstant(m, (char *) "SML_MANAGER_DISCONNECT_DONE", SML_MANAGER_DISCONNECT_DONE);
    PyModule_AddIntConstant(m, (char *) "SML_MANAGER_TRANSPORT_ERROR", SML_MANAGER_TRANSPORT_ERROR);
    PyModule_AddIntConstant(m, (char *) "SML_MANAGER_SESSION_NEW", SML_MANAGER_SESSION_NEW);
    PyModule_AddIntConstant(m, (char *) "SML_MANAGER_SESSION_FINAL", SML_MANAGER_SESSION_FINAL);
    PyModule_AddIntConstant(m, (char *) "SML_MANAGER_SESSION_END", SML_MANAGER_SESSION_END);
    PyModule_AddIntConstant(m, (char *) "SML_MANAGER_SESSION_FLUSH", SML_MANAGER_SESSION_FLUSH);
    PyModule_AddIntConstant(m, (char *) "SML_MANAGER_SESSION_WARNING", SML_MANAGER_SESSION_WARNING);
    PyModule_AddIntConstant(m, (char *) "SML_MANAGER_SESSION_ERROR", SML_MANAGER_SESSION_ERROR);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_VERSION_UNKNOWN", SML_DEVINF_VERSION_UNKNOWN);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_VERSION_10", SML_DEVINF_VERSION_10);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_VERSION_11", SML_DEVINF_VERSION_11);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_VERSION_12", SML_DEVINF_VERSION_12);
    PyModule_AddIntConstant(m, (char *) "SML_CHANGE_UNKNOWN", SML_CHANGE_UNKNOWN);
    PyModule_AddIntConstant(m, (char *) "SML_CHANGE_ADD", SML_CHANGE_ADD);
    PyModule_AddIntConstant(m, (char *) "SML_CHANGE_REPLACE", SML_CHANGE_REPLACE);
    PyModule_AddIntConstant(m, (char *) "SML_CHANGE_DELETE", SML_CHANGE_DELETE);
    PyModule_AddIntConstant(m, (char *) "SML_SAN_UIMODE_UNSPECIFIED", SML_SAN_UIMODE_UNSPECIFIED);
    PyModule_AddIntConstant(m, (char *) "SML_SAN_UIMODE_BACKGROUND", SML_SAN_UIMODE_BACKGROUND);
    PyModule_AddIntConstant(m, (char *) "SML_SAN_UIMODE_INFORMATIVE", SML_SAN_UIMODE_INFORMATIVE);
    PyModule_AddIntConstant(m, (char *) "SML_SAN_UIMODE_USER", SML_SAN_UIMODE_USER);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_DEVTYPE_UNKNOWN", SML_DEVINF_DEVTYPE_UNKNOWN);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_DEVTYPE_PAGER", SML_DEVINF_DEVTYPE_PAGER);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_DEVTYPE_HANDHELD", SML_DEVINF_DEVTYPE_HANDHELD);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_DEVTYPE_PDA", SML_DEVINF_DEVTYPE_PDA);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_DEVTYPE_PHONE", SML_DEVINF_DEVTYPE_PHONE);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_DEVTYPE_SMARTPHONE", SML_DEVINF_DEVTYPE_SMARTPHONE);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_DEVTYPE_SERVER", SML_DEVINF_DEVTYPE_SERVER);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_DEVTYPE_WORKSTATION", SML_DEVINF_DEVTYPE_WORKSTATION);
    PyModule_AddIntConstant(m, (char *) "SML_COMMAND_TYPE_UNKNOWN", SML_COMMAND_TYPE_UNKNOWN);
    PyModule_AddIntConstant(m, (char *) "SML_COMMAND_TYPE_ALERT", SML_COMMAND_TYPE_ALERT);
    PyModule_AddIntConstant(m, (char *) "SML_COMMAND_TYPE_SYNC", SML_COMMAND_TYPE_SYNC);
    PyModule_AddIntConstant(m, (char *) "SML_COMMAND_TYPE_PUT", SML_COMMAND_TYPE_PUT);
    PyModule_AddIntConstant(m, (char *) "SML_COMMAND_TYPE_HEADER", SML_COMMAND_TYPE_HEADER);
    PyModule_AddIntConstant(m, (char *) "SML_COMMAND_TYPE_ADD", SML_COMMAND_TYPE_ADD);
    PyModule_AddIntConstant(m, (char *) "SML_COMMAND_TYPE_REPLACE", SML_COMMAND_TYPE_REPLACE);
    PyModule_AddIntConstant(m, (char *) "SML_COMMAND_TYPE_DELETE", SML_COMMAND_TYPE_DELETE);
    PyModule_AddIntConstant(m, (char *) "SML_COMMAND_TYPE_MAP", SML_COMMAND_TYPE_MAP);
    PyModule_AddIntConstant(m, (char *) "SML_COMMAND_TYPE_GET", SML_COMMAND_TYPE_GET);
    PyModule_AddIntConstant(m, (char *) "SML_COMMAND_TYPE_RESULTS", SML_COMMAND_TYPE_RESULTS);
    PyModule_AddIntConstant(m, (char *) "SML_FORMAT_TYPE_UNKNOWN", SML_FORMAT_TYPE_UNKNOWN);
    PyModule_AddIntConstant(m, (char *) "SML_FORMAT_TYPE_BASE64", SML_FORMAT_TYPE_BASE64);
    PyModule_AddIntConstant(m, (char *) "SML_SAN_VERSION_UNKNOWN", SML_SAN_VERSION_UNKNOWN);
    PyModule_AddIntConstant(m, (char *) "SML_SAN_VERSION_10", SML_SAN_VERSION_10);
    PyModule_AddIntConstant(m, (char *) "SML_SAN_VERSION_11", SML_SAN_VERSION_11);
    PyModule_AddIntConstant(m, (char *) "SML_SAN_VERSION_12", SML_SAN_VERSION_12);
    PyModule_AddIntConstant(m, (char *) "SML_DS_UNKNOWN_TYPE", SML_DS_UNKNOWN_TYPE);
    PyModule_AddIntConstant(m, (char *) "SML_DS_SERVER", SML_DS_SERVER);
    PyModule_AddIntConstant(m, (char *) "SML_DS_CLIENT", SML_DS_CLIENT);
    PyModule_AddIntConstant(m, (char *) "SML_AUTH_TYPE_UNKNOWN", SML_AUTH_TYPE_UNKNOWN);
    PyModule_AddIntConstant(m, (char *) "SML_AUTH_TYPE_BASIC", SML_AUTH_TYPE_BASIC);
    PyModule_AddIntConstant(m, (char *) "SML_AUTH_TYPE_MD5", SML_AUTH_TYPE_MD5);
    PyModule_AddIntConstant(m, (char *) "SML_TRANSPORT_CONNECTION_TYPE_UNKNOWN", SML_TRANSPORT_CONNECTION_TYPE_UNKNOWN);
    PyModule_AddIntConstant(m, (char *) "SML_TRANSPORT_CONNECTION_TYPE_SERIAL", SML_TRANSPORT_CONNECTION_TYPE_SERIAL);
    PyModule_AddIntConstant(m, (char *) "SML_TRANSPORT_CONNECTION_TYPE_BLUETOOTH", SML_TRANSPORT_CONNECTION_TYPE_BLUETOOTH);
    PyModule_AddIntConstant(m, (char *) "SML_TRANSPORT_CONNECTION_TYPE_IRDA", SML_TRANSPORT_CONNECTION_TYPE_IRDA);
    PyModule_AddIntConstant(m, (char *) "SML_TRANSPORT_CONNECTION_TYPE_NET", SML_TRANSPORT_CONNECTION_TYPE_NET);
    PyModule_AddIntConstant(m, (char *) "SML_TRANSPORT_CONNECTION_TYPE_USB", SML_TRANSPORT_CONNECTION_TYPE_USB);
    PyModule_AddIntConstant(m, (char *) "SML_SAN_INITIATOR_USER", SML_SAN_INITIATOR_USER);
    PyModule_AddIntConstant(m, (char *) "SML_SAN_INITIATOR_SERVER", SML_SAN_INITIATOR_SERVER);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_DATATYPE_UNKNOWN", SML_DEVINF_DATATYPE_UNKNOWN);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_DATATYPE_CHR", SML_DEVINF_DATATYPE_CHR);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_DATATYPE_INT", SML_DEVINF_DATATYPE_INT);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_DATATYPE_BOOL", SML_DEVINF_DATATYPE_BOOL);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_DATATYPE_BIN", SML_DEVINF_DATATYPE_BIN);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_DATATYPE_DATE", SML_DEVINF_DATATYPE_DATE);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_DATATYPE_PHONE", SML_DEVINF_DATATYPE_PHONE);
    PyModule_AddIntConstant(m, (char *) "SML_PROTOCOL_UNKNOWN", SML_PROTOCOL_UNKNOWN);
    PyModule_AddIntConstant(m, (char *) "SML_PROTOCOL_SYNCML", SML_PROTOCOL_SYNCML);
    PyModule_AddIntConstant(m, (char *) "SML_PROTOCOL_DM", SML_PROTOCOL_DM);
    PyModule_AddIntConstant(m, (char *) "SML_VERSION_UNKNOWN", SML_VERSION_UNKNOWN);
    PyModule_AddIntConstant(m, (char *) "SML_VERSION_10", SML_VERSION_10);
    PyModule_AddIntConstant(m, (char *) "SML_VERSION_11", SML_VERSION_11);
    PyModule_AddIntConstant(m, (char *) "SML_VERSION_12", SML_VERSION_12);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_CTCAP_UNKNOWN", SML_DEVINF_CTCAP_UNKNOWN);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_CTCAP_CTTYPE", SML_DEVINF_CTCAP_CTTYPE);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_CTCAP_PROPNAME", SML_DEVINF_CTCAP_PROPNAME);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_CTCAP_VALENUM", SML_DEVINF_CTCAP_VALENUM);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_CTCAP_DATATYPE", SML_DEVINF_CTCAP_DATATYPE);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_CTCAP_SIZE", SML_DEVINF_CTCAP_SIZE);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_CTCAP_DISPLAYNAME", SML_DEVINF_CTCAP_DISPLAYNAME);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_CTCAP_PARAMNAME", SML_DEVINF_CTCAP_PARAMNAME);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_CTCAP_VERCT", SML_DEVINF_CTCAP_VERCT);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_CTCAP_PROPERTY", SML_DEVINF_CTCAP_PROPERTY);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_CTCAP_PROPPARAM", SML_DEVINF_CTCAP_PROPPARAM);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_CTCAP_NOTRUNCATE", SML_DEVINF_CTCAP_NOTRUNCATE);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_CTCAP_MAXOCCUR", SML_DEVINF_CTCAP_MAXOCCUR);
    PyModule_AddIntConstant(m, (char *) "SML_DEVINF_CTCAP_MAXSIZE", SML_DEVINF_CTCAP_MAXSIZE);
    PyModule_AddIntConstant(m, (char *) "SML_SESSION_TYPE_SERVER", SML_SESSION_TYPE_SERVER);
    PyModule_AddIntConstant(m, (char *) "SML_SESSION_TYPE_CLIENT", SML_SESSION_TYPE_CLIENT);
    submodule = initsyncml_std();
    if (submodule == NULL) {
        return;
    }
    Py_INCREF(submodule);
    PyModule_AddObject(m, (char *) "std", submodule);
}
